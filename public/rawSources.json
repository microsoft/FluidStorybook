{"files":{"fluidObjects/badge/badge.types.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { IIconProps, IColor } from \"office-ui-fabric-react\";\nimport { SharedCell } from \"@fluidframework/cell\";\nimport { SharedMap } from \"@fluidframework/map\";\nimport { SharedObjectSequence } from \"@fluidframework/sequence\";\n\nexport interface IBadgeType {\n    key: string;\n    text: string;\n    iconProps: IIconProps;\n}\n\nexport interface IBadgeHistory {\n    value: IBadgeType;\n    timestamp: Date;\n}\n\nexport interface IBadgeModel {\n    currentCell: SharedCell;\n    optionsMap: SharedMap;\n    historySequence: SharedObjectSequence<IBadgeHistory>;\n}\n\nexport interface IBadgeClientProps {\n    model: IBadgeModel;\n}\n\nexport interface IBadgeViewProps {\n    options: IBadgeType[];\n    historyItems: IBadgeHistory[];\n    selectedOption: string | number;\n    addOption: (text: string, color: IColor) => void;\n    changeSelectedOption: (item: IBadgeType) => void;\n}\n"},"fluidObjects/badge/badgeClient.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport * as React from \"react\";\nimport { IColor } from \"office-ui-fabric-react\";\nimport { BadgeView } from \"./badgeView\";\nimport { IBadgeClientProps, IBadgeType } from \"./badge.types\";\n\n /**\n * The BadgeClient is a stateful, functional Data Object that stores Fluid getters in state\n * and passes those getters and setters to the BadgeView. The state is updated each time that\n * the Fluid DDS's are modified.\n */\n\nexport const BadgeClient: React.FC<IBadgeClientProps> = ({ model }: IBadgeClientProps) => {\n    // Setters\n    const changeSelectedOption = (newItem: IBadgeType): void => {\n        if (newItem.key !== model.currentCell.get().key) {\n            const len = model.historySequence.getItemCount();\n            model.historySequence.insert(len, [\n                {\n                    value: newItem,\n                    timestamp: new Date(),\n                },\n            ]);\n            model.currentCell.set(newItem);\n        }\n    };\n\n    const addOption = (text: string, color: IColor): void => {\n        if (text !== undefined) {\n            const newItem: IBadgeType = {\n                key: text,\n                text,\n                iconProps: {\n                    iconName: \"Contact\",\n                    style: { color: color.str },\n                },\n            };\n            model.optionsMap.set(text, newItem);\n            changeSelectedOption(newItem);\n        }\n    };\n\n    // Getters\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const getOptions = () => {\n        // Spread iterable out into an array\n        return [...model.optionsMap.values()];\n    };\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const getHistoryItems = () => {\n        // return history items in reverse order so that newest is first\n        const history = model.historySequence.getItems(0);\n        return history.reverse();\n    };\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const getSelectedOptionKey = () => {\n        return model.currentCell.get().key;\n    };\n\n    // Store Fluid data in React state\n    const [options, setOptions] = React.useState(getOptions());\n    const [historyItems, setHistoryItems] = React.useState(getHistoryItems());\n    const [selectedOption, setSelectedOption] = React.useState(getSelectedOptionKey());\n\n    // Watch for Fluid data updates and update React state\n    React.useEffect(() => {\n        model.currentCell.on(\"valueChanged\", () => {\n            setSelectedOption(getSelectedOptionKey());\n            setHistoryItems(getHistoryItems());\n        });\n    }, [getHistoryItems, getSelectedOptionKey, model.currentCell]);\n\n    React.useEffect(() => {\n        model.optionsMap.on(\"valueChanged\", () => {\n            setOptions(getOptions());\n        });\n    }, [getOptions, model.optionsMap]);\n\n    // Render View\n    return (\n        <BadgeView\n            options={options}\n            historyItems={historyItems}\n            selectedOption={selectedOption}\n            addOption={addOption}\n            changeSelectedOption={changeSelectedOption}\n        />\n    );\n};\n"},"fluidObjects/badge/badgeModel.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { DataObject, DataObjectFactory, ContainerRuntimeFactoryWithDefaultDataStore } from \"@fluidframework/aqueduct\";\nimport { SharedCell } from \"@fluidframework/cell\";\nimport { IFluidHandle } from \"@fluidframework/core-interfaces\";\nimport { SharedMap } from \"@fluidframework/map\";\nimport { SharedObjectSequence } from \"@fluidframework/sequence\";\nimport { IFluidHTMLView } from \"@fluidframework/view-interfaces\";\nimport { IBadgeModel, IBadgeHistory } from \"./badge.types\";\nimport { defaultItems } from \"./helpers\";\nimport { BadgeClient } from \"./badgeClient\";\n\nexport class Badge extends DataObject implements IBadgeModel, IFluidHTMLView {\n    currentCell!: SharedCell;\n    optionsMap!: SharedMap;\n    historySequence!: SharedObjectSequence<IBadgeHistory>;\n\n    public get IFluidHTMLView() { return this; }\n\n    private readonly currentId: string = \"value\";\n    private readonly historyId: string = \"history\";\n    private readonly optionsId: string = \"options\";\n\n    static factory = new DataObjectFactory(\n        'badge',\n        Badge,\n        [\n            SharedMap.getFactory(),\n            SharedCell.getFactory(),\n            SharedObjectSequence.getFactory(),\n        ],\n        {},\n    );\n\n    /**\n     * initializingFirstTime is called only once, it is executed only by the first client to open the Data Object\n     * and all work will resolve before the view is presented to any user.\n     *\n     * This method is used to perform Data Object setup, which can include setting an initial schema or initial values.\n     */\n    protected async initializingFirstTime() {\n        // Create a cell to represent the Badge's current state\n        const current = SharedCell.create(this.runtime);\n        current.set(defaultItems[0]);\n        this.root.set(this.currentId, current.handle);\n\n        // Create a map to represent the options for the Badge\n        const options = SharedMap.create(this.runtime);\n        defaultItems.forEach((v) => options.set(v.key, v));\n        this.root.set(this.optionsId, options.handle);\n\n        // Create a sequence to store the badge's history\n        const badgeHistory = SharedObjectSequence.create<IBadgeHistory>(this.runtime);\n        badgeHistory.insert(0, [{\n            value: current.get(),\n            timestamp: new Date(),\n        }]);\n        this.root.set(this.historyId, badgeHistory.handle);\n    }\n\n    /**\n     * In order to retrieve values from the SharedDirectory/Map, we must use await, so we need an async function.\n     * This function stashes local references to the Shared objects that we want to pass into the React component\n     * in render (see FluidReactClient). That way our render method, which cannot be async, can pass in the Shared\n     * object refs as props to the React component.\n     */\n    protected async hasInitialized() {\n        [ this.currentCell, this.optionsMap, this.historySequence ] = await Promise.all([\n            this.root.get<IFluidHandle<SharedCell>>(this.currentId).get(),\n            this.root.get<IFluidHandle<SharedMap>>(this.optionsId).get(),\n            this.root.get<IFluidHandle<SharedObjectSequence<IBadgeHistory>>>(this.historyId).get(),\n        ]);\n    }\n\n    public render(div: HTMLElement) {\n        ReactDOM.render(<BadgeClient model={this} />, div);\n    }\n}\n\nexport const BadgeContainerFactory = new ContainerRuntimeFactoryWithDefaultDataStore(\n    'badge',\n    new Map([['badge', Promise.resolve(Badge.factory)]])\n  );\n"},"fluidObjects/badge/badgeView.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport React, { useState, useMemo } from \"react\";\nimport {\n    ActivityItem,\n    DefaultButton,\n    PrimaryButton,\n    DirectionalHint,\n    Dialog,\n    DialogFooter,\n    HoverCard,\n    HoverCardType,\n    Icon,\n    initializeIcons,\n    ColorPicker,\n    getColorFromString,\n    IColor,\n    Stack,\n    TextField,\n    IContextualMenuItem,\n} from \"office-ui-fabric-react\";\nimport { MotionAnimations } from \"@uifabric/fluent-theme\";\nimport { IBadgeViewProps, IBadgeType } from \"./badge.types\";\nimport {\n    getItemsFromOptionsMap,\n    getRelativeDate,\n    getButtonStyles,\n} from \"./helpers\";\n\n// Initialize icon font used in Fluent UI\ninitializeIcons();\n\n// The BadgeView is completely unaware of the Fluid data structures. It only renders what is currently in Client state\n// and uses Client provided functions to modify Fluid data, which is then fed back into state.\n\nexport const BadgeView: React.FC<IBadgeViewProps> = (props: IBadgeViewProps) => {\n    const {\n        options,\n        historyItems,\n        selectedOption,\n        addOption,\n        changeSelectedOption,\n    } = props;\n\n    const currentOption = options.find((option) => option.key === selectedOption);\n\n    // Set up local state for our custom status creator\n\n    const [isCustomStatusVisible, setIsCustomStatusVisible] = useState<boolean>(false);\n    const [customStatusColor, setCustomStatusColor] = useState<IColor>(\n        getColorFromString(\"#fff\") as IColor,\n    );\n    const [customStatusText, setCustomStatusText] = useState<string>(\"\");\n\n    // Set up event handlers\n    const onStatusClick = (_: any, item: IContextualMenuItem | undefined): void => {\n        const itemSafe = item ? item : {key: \"new\"};\n        switch (itemSafe.key) {\n            case \"new\":\n                setIsCustomStatusVisible(true);\n                break;\n            default:\n                changeSelectedOption(item as IBadgeType);\n        }\n    };\n\n    const closeCustomStatus = (): void => {\n        setIsCustomStatusVisible(false);\n    };\n\n    const onSaveCustomStatus = (): void => {\n        if (customStatusText !== \"\") {\n            addOption(customStatusText, customStatusColor);\n            setCustomStatusText(\"\");\n        }\n        closeCustomStatus();\n    };\n\n    // Handle change events. These could include data validation.\n    const updateCustomStatusColor = (_: any, colorObj: IColor) => {\n        setCustomStatusColor(colorObj);\n    };\n\n    const updateCustomStatusText = (_: any, newValue: string | undefined) => {\n        \n        setCustomStatusText(newValue ? newValue : \"\");\n    };\n\n    // Create the content for the history card\n    const historyCardContent = (): JSX.Element => {\n        // eslint-disable-next-line react/prop-types\n        const history = historyItems.map((x, i) => {\n            return (\n                <ActivityItem\n                    key={i}\n                    activityDescription={`Set to ${x.value.text}`}\n                    timeStamp={getRelativeDate(x.timestamp)}\n                    activityIcon={<Icon {...x.value.iconProps} />}\n                />\n            );\n        });\n\n        return <div style={{ padding: \"16px 24px\" }}>{history}</div>;\n    };\n\n    // Only recompute button styles when current option changes\n    const buttonStyles = useMemo(\n        () => getButtonStyles(currentOption!.iconProps!.style!.color!),\n        [currentOption],\n    );\n\n    // Render our main view\n    return (\n        <div\n            style={{\n                animation: MotionAnimations.scaleDownIn,\n                display: \"inline-block\",\n            }}\n        >\n            <HoverCard\n                plainCardProps={{\n                    onRenderPlainCard: historyCardContent,\n                    directionalHint: DirectionalHint.rightTopEdge,\n                }}\n                type={HoverCardType.plain}\n            >\n                <DefaultButton\n                    text={currentOption!.text}\n                    iconProps={{\n                        iconName: currentOption!.iconProps.iconName,\n                    }}\n                    menuProps={{\n                        isBeakVisible: false,\n                        shouldFocusOnMount: true,\n                        items: getItemsFromOptionsMap(options),\n                        onItemClick: onStatusClick,\n                    }}\n                    styles={buttonStyles}\n                />\n            </HoverCard>\n\n            <Dialog\n                hidden={!isCustomStatusVisible}\n                onDismiss={closeCustomStatus}\n                dialogContentProps={{ title: \"Add a custom status\" }}\n                modalProps={{\n                    isBlocking: false,\n                    styles: { main: { maxWidth: 450 } },\n                }}\n            >\n                <Stack>\n                    <TextField\n                        placeholder=\"Custom status name\"\n                        onChange={updateCustomStatusText}\n                    />\n                    <ColorPicker\n                        color={customStatusColor}\n                        onChange={updateCustomStatusColor}\n                        alphaSliderHidden={true}\n                    />\n                </Stack>\n                <DialogFooter>\n                    <PrimaryButton onClick={onSaveCustomStatus} text=\"Save\" />\n                    <DefaultButton onClick={closeCustomStatus} text=\"Cancel\" />\n                </DialogFooter>\n            </Dialog>\n        </div>\n    );\n};\n"},"fluidObjects/badge/helpers.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport {\n    ContextualMenuItemType,\n    IContextualMenuItem,\n    IColor,\n    getColorFromHSV,\n    getColorFromString,\n    IButtonStyles,\n} from \"office-ui-fabric-react\";\nimport { SharedColors } from \"@uifabric/fluent-theme\";\nimport { IBadgeType } from \"./badge.types\";\n\nexport const defaultItems: IBadgeType[] = [\n    {\n        key: \"drafting\",\n        text: \"Drafting\",\n        iconProps: {\n            iconName: \"Edit\",\n            style: {\n                color: SharedColors.cyanBlue10,\n            },\n        },\n    },\n    {\n        key: \"reviewing\",\n        text: \"Reviewing\",\n        iconProps: {\n            iconName: \"Chat\",\n            style: {\n                color: SharedColors.orange20,\n            },\n        },\n    },\n    {\n        key: \"complete\",\n        text: \"Complete\",\n        iconProps: {\n            iconName: \"Completed\",\n            style: {\n                color: SharedColors.green10,\n            },\n        },\n    },\n    {\n        key: \"archived\",\n        text: \"Archived\",\n        iconProps: {\n            iconName: \"Archive\",\n            style: {\n                color: SharedColors.magenta10,\n            },\n        },\n    },\n];\n\nexport const getItemsFromOptionsMap = (options: IContextualMenuItem[]) => {\n    const mapItems = [...options];\n\n    mapItems.push({\n        key: \"divider_1\",\n        itemType: ContextualMenuItemType.Divider,\n    });\n    mapItems.push({\n        key: \"new\",\n        text: \"Set custom...\",\n        iconProps: {\n            iconName: \"Add\",\n        },\n    });\n\n    return mapItems;\n};\n\nexport const getTextColor = (c: IColor) => {\n    // eslint-disable-next-line max-len\n    // https://stackoverflow.com/questions/3942878/how-to-decide-font-color-in-white-or-black-depending-on-background-color\n    return c.r * 0.299 + c.g * 0.587 + c.b * 0.114 > 186\n        ? \"#000000\"\n        : \"#ffffff\";\n};\n\nexport const getButtonStyles = (baseColor: string): IButtonStyles => {\n    let color = getColorFromString(baseColor);\n    if (color === undefined) {\n        color = getColorFromString(\"grey\") as IColor;\n    }\n    const colorHover = getColorFromHSV({\n        h: color.h,\n        s: color.s,\n        v: color.v + 5,\n    });\n    const colorPressed = getColorFromHSV({\n        h: color.h,\n        s: color.s,\n        v: color.v - 5,\n    });\n    const textColor = getTextColor(color);\n    const animation: string = \"all 0.15s ease-in\";\n\n    return {\n        label: {\n            color: textColor,\n        },\n        icon: {\n            color: textColor,\n        },\n        menuIcon: {\n            color: textColor,\n        },\n        root: {\n            backgroundColor: color.str,\n            transition: animation,\n        },\n        rootHovered: {\n            backgroundColor: colorHover.str,\n        },\n        rootPressed: {\n            backgroundColor: colorPressed.str,\n        },\n        rootExpanded: {\n            backgroundColor: colorPressed.str,\n        },\n    };\n};\n\nexport const getRelativeDate = (timestamp: Date): string => {\n    // https://stackoverflow.com/questions/7641791/javascript-library-for-human-friendly-relative-date-formatting\n    const delta = Math.round(\n        (new Date().getTime() - new Date(timestamp).getTime()) / 1000,\n    );\n\n    const minute = 60;\n    const hour = minute * 60;\n    const day = hour * 24;\n\n    if (delta < 30) {\n        return \"just now\";\n    } else if (delta < 3 * minute) {\n        return \"a few minutes ago\";\n    } else if (delta < hour) {\n        return `${Math.floor(delta / minute)} minutes ago`;\n    } else if (Math.floor(delta / hour) < 3) {\n        return \"a few hours ago.\";\n    } else if (delta < day) {\n        return `${Math.floor(delta / hour)} hours ago`;\n    } else if (delta < day * 2) {\n        return \"yesterday\";\n    } else {\n        return timestamp.toUTCString();\n    }\n};\n"},"fluidObjects/brainstorm/app.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getDefaultObjectFromContainer } from \"@fluidframework/aqueduct\";\nimport { getTinyliciousContainer } from \"@fluidframework/get-tinylicious-container\";\n\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\nimport { NoteroContainerFactory } from \"./container\"\nimport { Notero } from \"./fluid-object\";\nimport { NoteroView } from \"./view\";\n\n// Since this is a single page fluid application we are generating a new document id\n// if one was not provided\nlet createNew = false;\nif (window.location.hash.length === 0) {\n    createNew = true;\n    window.location.hash = Date.now().toString();\n}\nconst documentId = window.location.hash.substring(1);\n\n/**\n * This is a helper function for loading the page. It's required because getting the Fluid Container\n * requires making async calls.\n */\nasync function start() {\n    // Get the Fluid Container associated with the provided id\n    const container = await getTinyliciousContainer(documentId, NoteroContainerFactory, createNew);\n\n    // Get the Default Object from the Container (DiceRoller)\n    const defaultObject = await getDefaultObjectFromContainer<Notero>(container);\n\n    // Render the ui using React\n    ReactDOM.render(\n        <NoteroView model= {defaultObject}/>,            \n        document.getElementById(\"content\")\n    );\n}\n\nstart().catch((e)=> {\n    console.error(e);\n    console.log(\n        \"%cEnsure you are running the Tinylicious Fluid Server\\nUse:`npm run start:server`\",\n        \"font-size:30px\");\n});\n"},"fluidObjects/brainstorm/container.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    ContainerRuntimeFactoryWithDefaultDataStore,\n} from \"@fluidframework/aqueduct\";\n\nimport { NoteroInstantiationFactory } from \"./fluid-object\";\n\n/**\n * This does setup for the Container. The SimpleModuleInstantiationFactory also enables dynamic loading in the\n * EmbeddedComponentLoader.\n *\n * There are two important things here:\n * 1. Default Component name\n * 2. Map of string to factory for all components\n *\n * In this example, we are only registering a single component, but more complex examples will register multiple\n * components.\n */\nexport const NoteroContainerFactory = new ContainerRuntimeFactoryWithDefaultDataStore(\n    NoteroInstantiationFactory.type,\n    new Map([\n        NoteroInstantiationFactory.registryEntry,\n    ]),\n);\n"},"fluidObjects/brainstorm/fluid-object/NoteWithVotes.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { INote, IUser, INoteWithVotes } from \"./interfaces\";\n/**\n * This class is never used to create objects that are stored in Fluid DDSs.\n */\nexport class NoteWithVotes implements INoteWithVotes {\n    public text: string;\n    public user: IUser;\n    public id: string;\n    constructor(note: INote, public votes: number, public currentUserVoted: boolean) {\n        this.text = note.text;\n        this.user = note.user;\n        this.id = note.id;\n    }\n}"},"fluidObjects/brainstorm/fluid-object/demo.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { v4 as uuidv4 } from 'uuid';\n\nexport class FakeUser {\n    /**\n     * Purely for demo purposes.\n     */    \n    public static getFakeUserId(): string {        \n        return uuidv4();        \n    }    \n\n    /**\n     * Purely for demo purposes.\n     */\n    public static getFakeName(): string {\n        return this.fakeNames[Math.floor(Math.random() * this.fakeNames.length)];\n    }\n\n    /**\n     * Purely for demo purposes.\n     */\n    private static fakeNames: string[] = [\n        \"Azariah\",\n        \"Charlie\",\n        \"Justice\",\n        \"Remy\",\n        \"Oakley\",\n        \"Skyler\",\n        \"Finley\",\n        \"Dakota\",\n        \"Tatum\",\n        \"Jamie\",\n        \"Armani\",\n        \"Briar\",\n        \"Landry\",\n        \"River\",\n        \"Emerson\",\n        \"Sage\",\n        \"Casey\",\n        \"Phoenix\",\n        \"Amari\",\n        \"Shiloh\",\n        \"Rory\",\n        \"Hayden\",\n        \"Milan\",\n        \"Remington\",\n        \"Royal\",\n        \"Lennox\",\n        \"Lennon\",\n        \"Sutton\",\n        \"Blake\",\n        \"Rowan\",\n        \"Ari\",\n        \"Kamryn\",\n        \"Parker\",\n        \"Emory\",\n        \"Alexis\",\n        \"Karsyn\",\n        \"Dallas\",\n        \"Leighton\",\n        \"Reign\",\n        \"Sawyer\",\n        \"Ellis\",\n        \"Eden\",\n        \"Rylan\",\n        \"Peyton\",\n        \"Avery\",\n        \"Ariel\",\n        \"Elliott\",\n        \"Quinn\",\n        \"Riley\",\n        \"Lyric\"\n    ]\n}\n\nexport class AutoNote {\n    /**\n     * Purely for demo purposes.\n     */\n    public static createDemoNote(): string {\n        const text = this.demoText[Math.floor(Math.random() * this.demoText.length)]\n        return text;\n    }\n\n    /**\n     * Purely for demo purposes.\n     */\n    private static demoText: string[] = [\n        \"Formal Friday!!!\",\n        \"Free hot stone massages :-)\",\n        \"An enormous ball pit.\",\n        \"At least one meeting free day each week.\",\n        \"An espresso cart at least once a month.\",\n        \"Personal trainer and dietitian on call 24/7\",\n        \"Motivational posters. With cats.\",\n        \"A little more recognition, thanks.\",\n        \"Full spectrum lighting and higher oxygen in the air.\",\n        \"Yoga balls instead of chairs.\",\n        \"More virtual brainstorming.\",\n        \"Fewer snakes.\",\n        \"Motivational posters. With dogs.\",\n        \"Candy dispensers by the door.\",\n        \"Get rid of all the candy.\",\n        \"Baskets of ferrets in the break room. Or just ferrets.\",\n        \"80s themed game nights.\",\n        \"Fewer motivational posters.\",\n        \"A gym where we can workout with the personal trainers\",\n        \"Table tennis. Competitive table tennis.\"\n    ]\n}"},"fluidObjects/brainstorm/fluid-object/index.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport { NoteroInstantiationFactory } from \"./main\";\n\nexport * from \"./main\";"},"fluidObjects/brainstorm/fluid-object/interfaces.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Note that the model primarily uses interfaces, not classes.\n * When objects are stored in Fluid DDSs,\n * they are serialized and deserialized over the wire.\n * Using interfaces avoids any issues with calling functions \n * that are no longer present on an object. \n */\n   \nexport interface INote {\n    id: string;\n    text: string;\n    user: IUser;\n}\n\nexport interface INoteWithVotes extends INote {\n    currentUserVoted: boolean;\n    votes: number;\n}\n\nexport interface IUser {\n    id: string;\n    name: string;\n}\n\nexport interface IBallot {\n    id: string,\n    noteId: string,\n    user: IUser\n}\n\nexport interface INoteroDataModel {\n    getUsers: () => IUser[];\n    getUser: () => IUser;\n    addUser: () => void;\n    getNotesFromBoard: () => INoteWithVotes[];\n    createDemoNote: () => string;\n    createNote: (text: string) => void;\n    vote: (note: INote) => void;\n    on(event: \"change\", listener: () => void): this;\n    off(event: \"change\", listener: () => void): this;\n}"},"fluidObjects/brainstorm/fluid-object/main.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport {\n    DataObject,\n    DataObjectFactory,\n} from \"@fluidframework/aqueduct\";\nimport { SharedMap } from \"@fluidframework/map\";\nimport { IFluidHandle } from \"@fluidframework/core-interfaces\";\n\nimport {\n    IBallot,\n    INote,\n    INoteroDataModel,\n    IUser,\n} from \"./interfaces\";\nimport { NoteWithVotes } from \"./NoteWithVotes\";\nimport { AutoNote, FakeUser } from \"./demo\";\n\nexport class Notero extends DataObject implements INoteroDataModel {\n\n    // Local references to the SharedMaps used in this component\n    private notesMap: SharedMap;\n    private votesMap: SharedMap;\n    private usersMap: SharedMap;\n\n    // stores a fake userId as we aren't using true auth for this demo\n    private userId: string;\n\n    /**\n     * initializingFirstTime is called only once,\n     * it is executed only by the first client to open the\n     * component and all work will resolve before the view\n     * is presented to any user.\n     *\n     * This method is used to perform component setup,\n     * which can include setting an initial schema or initial values.\n     */\n    protected async initializingFirstTime() {\n        // Create SharedMaps for the notes, votes, and users\n        this.createSharedMap('notes');\n        this.createSharedMap('votes');\n        this.createSharedMap('users');\n    }\n\n    /**\n     * Creates a shared map with the provided id. The id must be unique.\n     */\n    private createSharedMap(id: string): void {\n        const map = SharedMap.create(this.runtime);\n        this.root.set(id, map.handle);\n    }\n\n    /**\n    * hasInitialized is called every\n    * time a client joins a session.\n    *\n    * This method is used to perform tasks required\n    * for each client like initializing event listeners.\n    */\n    protected async hasInitialized() {\n        // Create local references to the SharedMaps.\n        // Otherwise, they need to be called async which is inconvenient.\n        this.notesMap = await this.root.get<IFluidHandle<SharedMap>>(\"notes\").get();\n        this.votesMap = await this.root.get<IFluidHandle<SharedMap>>(\"votes\").get();\n        this.usersMap = await this.root.get<IFluidHandle<SharedMap>>(\"users\").get();\n\n        // Add the current user to set of collaborators.\n        this.addUser();\n\n        // Set up event listeners to update the ui when data changes               \n        this.createEventListeners(this.notesMap);\n        this.createEventListeners(this.votesMap);\n        this.createEventListeners(this.usersMap);\n    }\n\n    /**\n     * Helper function to set up event listeners for shared objects\n     */\n    private createEventListeners(sharedMap: SharedMap): void {\n        // Set up an event listener for changes to values in the SharedMap\n        sharedMap.on(\"valueChanged\", () => {\n            this.emit(\"change\");\n        });\n\n        //Set up an event listener for clearing the data in a SharedMap\n        sharedMap.on(\"clear\", () => {\n            this.emit(\"change\");\n        });\n\n        const quorum = this.context.getQuorum();\n        quorum.on(\"addMember\", () => {\n            this.emit(\"change\");\n        });\n\n        quorum.on(\"removeMember\", () => {\n            this.emit(\"change\");\n        });\n    }\n\n    public createDemoNote = (): string => {\n        return AutoNote.createDemoNote()\n    }\n\n    /*\n     * Creates a note and adds it to the notesMap SharedMap\n     */\n    public createNote = (text: string): void => {\n        if (text) {\n            const note: INote = {\n                id: uuidv4(),\n                text: text,\n                user: this.getUser()\n            };\n            this.notesMap.set(note.id, note);\n        }\n    }\n\n    /*\n     * Adds or removes a \"ballot\" to the vote count for a note\n     */\n    public vote = (note: INote): void => {\n        // Gets the current user\n        const user = this.getUser();\n\n        // Create a unique id keyed off the current user id and the note id\n        const id = note.id + user.id;\n\n        // Create a ballot object literal that encapsulates the information about\n        // the vote to store in the votesMap Fluid DDS\n        const ballot: IBallot = {\n            id: id,\n            noteId: note.id,\n            user: user\n        };\n\n        // Check to see if the current user already voted.\n        // If so, remove the vote, otherwise, add it\n        if (this.votesMap.has(ballot.id)) {\n            this.votesMap.delete(ballot.id); // removes the ballot from the votesMap\n        } else {\n            this.votesMap.set(ballot.id, ballot); // adds the ballot to the votesMap\n        }\n    }\n\n    /**\n     * Fetches notes and their votes from the notesMap SharedMap\n     * and the votesMap SharedMap and packages them in an array\n     * of local objects (NoteWithVotes) for consumption by the React ui\n     */\n    public getNotesFromBoard = (): NoteWithVotes[] => {\n        // Initialize an array of objects that will contain all the\n        // information necessary for React to render the notes\n        let notes: NoteWithVotes[] = [];\n\n        // Call a function that returns a map of note ids,\n        // the number of votes each note received\n        // and whether the current user voted\n        const votes = this.countVotes();\n\n        // Iterate through all the notes to populate the array of NoteWithVotes\n        // objects to pass into the React UI\n        this.notesMap.forEach((i: INote) => {\n            let numVotes = 0;\n            let voted = false;\n            if (votes.has(i.id)) {\n                numVotes = votes.get(i.id).count;\n                voted = votes.get(i.id).voted;\n            }\n            notes.push(new NoteWithVotes(i, numVotes, voted))\n        });\n        return notes;\n    }\n\n    /**\n     * Uses the votesMap and the notesMap SharedMaps to aggregate votes for\n     * consumption by the React ui - called by getNotesFromBoard()\n     */\n    private countVotes(): Map<string, { count: number, voted: boolean }> {\n        // Initialize a map indexed on note id where the value is an\n        // object literal containing the vote count and\n        // whether the current user voted\n        let voteCounts = new Map();\n\n        // Get the current user\n        const user = this.getUser();\n\n        // Iterate through all the \"ballots\" in votesMap to count them\n        // and put them in the voteCounts map\n        this.votesMap.forEach((i: IBallot) => {\n            // Check if there is already an item with this note's id\n            if (voteCounts.has(i.noteId)) {\n                // Update the vote count by one and test to see if\n                // this vote came from the current user and set\n                // voted to true if it did\n                voteCounts.set(\n                    i.noteId,\n                    {\n                        count: voteCounts.get(i.noteId).count + 1,\n                        voted: (i.user.id === user.id) || voteCounts.get(i.noteId).voted\n                    });\n            } else {\n                // Create a new item with indexed on the current note id and see if this vote came from the \n                // current user and set voted to true if it did\n                voteCounts.set(\n                    i.noteId,\n                    {\n                        count: 1,\n                        voted: (i.user.id === user.id)\n                    });\n            }\n        });\n        return voteCounts;\n    }\n\n    /**\n     * Creates a \"fake\" user based on a fake user id and a fake name.\n     * Only use this code for protoyping and demos.\n     */\n    public addUser = (): void => {\n        // Check for a userId in SessionStorage - this prevents refresh from generating a new user\n        // Removing since this breaks side by side \"local\" mode\n        // if (sessionStorage.getItem('userId') &&\n        //     this.usersMap.get<IUser>(sessionStorage.getItem('userId'))) {\n        //     this.userId = sessionStorage.getItem('userId'); //This session might have has a user\n        // } else {\n            const user: IUser = {\n                id: FakeUser.getFakeUserId(),\n                name: FakeUser.getFakeName()\n            };\n            this.userId = user.id;\n            sessionStorage.setItem('userId', user.id);\n            this.usersMap.set(user.id, user);\n        // }\n    }\n\n    /**\n     * Get the IUser literal object for the current user.\n     */\n    public getUser = (): IUser => {\n        return this.usersMap.get<IUser>(this.userId);\n    }\n\n    /**\n     * Get an array of all IUser literal objects for users\n     * who have joined the session (even if they have left). \n     */\n    public getUsers(): IUser[] {\n        const users: IUser[] = [];\n        this.usersMap.forEach((i: IUser) => {\n            users.push(i);\n        });\n        return users;\n    }\n}\n\n/**\n * The DataObjectFactory declares the component\n * and defines any additional distributed data structures.\n * To add a SharedSequence, SharedMap, or any other\n * structure, put it in the array below.\n * \n * Note: This project uses SharedMap so it is added below...\n */\nexport const NoteroInstantiationFactory = new DataObjectFactory(\n    \"Notero\",\n    Notero,\n    [\n        SharedMap.getFactory(),\n    ],\n    {},\n);\n"},"fluidObjects/brainstorm/index.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport * from \"./container\";\nexport * from \"./fluid-object\";\nexport * from \"./view\";\n"},"fluidObjects/brainstorm/styles.scss":{"raw":"body .sticky-storm {\n    background-color:white;\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n\n\n.note {\n    display: inline-block;\n    position: relative;\n    width: 90px;\n    height: 90px;\n    background-color: #ffc;\n    box-shadow: 0.1em 0.2em 0.4em rgba(0, 0, 0, 0.15);    \n    margin: .5em;\n    cursor: pointer;\n    user-select: none;\n    padding: .2em;\n    transition: transform .2s ease-out;           \n  } \n\n  .note:nth-child(even) {\n    transform:rotate(3deg);    \n    position:relative;\n    top:.2em;\n  }\n  \n  .note:nth-child(3n) {\n    transform:rotate(-4deg);    \n    position:relative;\n    top:-.2em;\n  }\n\n  .note:nth-child(5n) {\n    transform:rotate(5deg);    \n    position:relative;\n    top:-.4em;\n  }\n\n  .note:hover{\n    box-shadow: 0 0.4em 0.8em rgba(0, 0, 0, 0.15);    \n  }\n\n  .note.placeholder {\n    background-color: transparent;\n  }\n\n  .faded {\n    color: lightgrey;    \n  }\n  \n  .note.others {    \n    background-color: #fff;\n    color: #bbb;\n  }  \n\n  .note-editor {       \n    transform:rotate(-2deg);    \n  }\n\n  .note-editor:hover {\n    box-shadow: 0 0.4em 0.6em rgba(0, 0, 0, 0.15);\n  }\n\n.note-text {\n  display: block;\n  font-family: \"Comic Sans MS\", \"Comic Sans\", sans-serif;      \n  padding: 0;\n  margin: 0;  \n  font-size: 13px;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  border: none;\n  outline: 0px solid transparent;    \n}\n\n.theme {\n  display: inline-block;  \n  padding: 0;\n  margin: 0;  \n  font-size: 1em;\n  font-weight: bold;\n  display: inline-block;\n  vertical-align: middle;\n  margin-left: auto;\n  align-self: flex-end;\n  width: fit-content;\n  height: fit-content;\n  overflow: hidden;\n  border: none;\n  outline: 0px solid transparent;\n  color: #AAA;\n}\n\n.note-badge {\n  display: inline-block;\n  min-width: 1.4em;\n  padding: 0 0 .1em 0;\n  border-radius: 50%;\n  font-size: .6em;\n  font-weight: bold;\n  text-align: center;\n  background: #fff;\n  color: black;\n  position: absolute;\n  right: -0.5em;\n  top: -0.25em;\n  z-index: 999;\n  box-shadow: 0 0.1em 0.2em rgba(0,0,0,0.15);\n  border: solid green .2em;\n}\n\n  .note-badge.voted {\n    background: green;\n    color: white;\n  }\n\nbutton {\n  display: inline-block;\n  vertical-align: middle;\n  border: none;\n  border-radius: 0.2em;\n  margin: .5em;\n  margin-left: 1em;\n  padding: .5em 2em .5em 2em;\n  text-decoration: none;\n  background: #666;\n  color: #fff;  \n  font-size: 10px;\n  cursor: pointer;  \n  transition: 150ms ease-in-out, transform 50ms ease;\n  height: 2em;\n  width: 12.5em;\n  user-select: none;    \n}\n\n  button:hover, .sticky-storm button:focus {\n    background: #0053ba;\n  }\n\n  button:focus {\n    outline: none;    \n  }\n\n  button:active {\n    transform: scale(0.98);\n  } \n\n  button:disabled {\n    background: #ccc;\n  }\n\n.pad {\n  display: flex;\n  flex: 1;\n  flex-wrap: nowrap;\n  align-items: center;\n  background-color: #eee;\n  padding: .5em;  \n}\n\n.userName {\n  flex:none;\n  position: absolute;\n  right: 0;\n  top: 0;\n  margin-top: 55px;\n  margin-right: 40px;\n  z-index: 999;\n  box-shadow: 0 0.4em 0.6em rgba(0, 0, 0, 0.15);  \n  font-weight: bold;\n  // margin-left: 2em;\n  padding: 0em .5em .2em .5em;\n  background: white;\n  border-radius: 0.3em;\n  font-size: 1em;\n  border: solid #ccc;\n}\n\n.userCount {\n  font-weight: normal;\n  font-size: .7em;\n  padding-left: .5em;\n\n}\n\n.board {\n  display: flex;\n  flex: 1;\n  flex-wrap: wrap;    \n  align-items: center;   \n  margin: 1em;  \n  background-color: white;\n}\n\n.container {\n  display: flex;    \n  align-items: center;\n  background-color: #bbb;    \n  margin: 1em;    \n}\n}"},"fluidObjects/brainstorm/view.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport React, { useState, useEffect } from \"react\";\nimport {\n  INote,\n  INoteroDataModel,\n  INoteWithVotes,\n  IUser,\n} from \"./fluid-object/interfaces\";\n\n// eslint-disable-next-line import/no-unassigned-import\nimport \"./styles.scss\";\n\ninterface NoteroViewState {\n  user: IUser;\n  users: IUser[];\n  notes: INoteWithVotes[];\n}\n\nexport interface NoteroViewProps {\n  model: INoteroDataModel;\n}\n\nexport function NoteroView(props: NoteroViewProps) {\n  const generateState = () => {\n    return {\n      user: props.model.getUser(),\n      users: props.model.getUsers(),\n      notes: props.model.getNotesFromBoard(),\n    };\n  };\n  const [state, setState] = useState<NoteroViewState>(generateState());\n  const [highlightMine, setHighlightMine] = useState<boolean>();\n\n  // Setup a listener that\n  useEffect(() => {\n    const onChange = () => setState(generateState());\n    props.model.on(\"change\", onChange);\n\n    // useEffect runs after the first render so we will update the view again incase there\n    // were changes that came into the model in between generating initialState and setting\n    // the above event handler\n    onChange(); \n    return () => {\n        // When the view dismounts remove the listener to avoid memory leaks\n        props.model.off(\"change\", onChange);\n    };\n  }, []);\n\n  return (\n    <div className=\"sticky-storm\">\n      <Pad\n        create={props.model.createNote}\n        demo={props.model.createDemoNote}\n        user={state.user}\n        users={state.users}\n        clear={() => alert(\"clear not implemented\")}\n        setHighlightMine={setHighlightMine}\n        highlightMine={highlightMine}\n      />\n      <Board\n        notes={state.notes}\n        vote={props.model.vote}\n        user={state.user}\n        highlightMine={highlightMine}\n      />\n    </div>\n  );\n}\n\ninterface BoardProps {\n  notes: INoteWithVotes[];\n  vote: (note: INote) => void;\n  user: IUser;\n  highlightMine: boolean;\n}\n\nfunction Board(props: BoardProps) {\n  return (\n    <div className=\"board\">\n      {props.notes.map((note) => {\n        return <Note\n          key={note.id}\n          note={note}\n          handleClick={props.vote}\n          count={note.votes}\n          user={props.user}\n          highlightMine={props.highlightMine}\n        />;\n      })}\n    </div>\n  );\n}\n\ninterface PadProps {\n  create: (text: string) => void;\n  demo: () => string;\n  user: IUser;\n  users: IUser[];\n  clear: () => void;\n  setHighlightMine: React.Dispatch<React.SetStateAction<boolean>>;\n  highlightMine: boolean;\n}\n\nfunction Pad(props: PadProps) {\n  const [element, setText] = useState<HTMLElement>();\n\n  const handleChange = (element: HTMLElement) => {\n    setText(element);\n  }\n\n  const handleCreate = () => {\n    if (element) {\n      props.create(element.innerText);\n      element.innerText = \"\";\n    }\n  }\n\n  const handleHighlight = () => {\n    props.setHighlightMine(!props.highlightMine)\n  }\n\n  return (\n    <div className=\"container\">\n      <div className=\"pad\">\n        <NoteEditor\n          handleChange={(element: any)=> handleChange(element)}\n          handleCreate={() => handleCreate()} demo={props.demo}\n        />\n        <Button\n          disabled={false}\n          text={\"Share my idea\"}\n          handleClick={handleCreate}\n        />\n        <Button\n          disabled={false}\n          text={(props.highlightMine) ? \"Stop highlighting\" : \"Highlight my ideas\"}\n          handleClick={handleHighlight}\n        />\n        {/* <Button\n          disabled={false}\n          text={\"Tidy up\"}\n          handleClick={props.clear}\n        /> */}\n        <UserName user={props.user} users={props.users} />\n      </div>\n    </div>\n  );\n}\n\ninterface UserNameProps {\n  user: IUser;\n  users: IUser[];\n}\n\nfunction UserName(props: UserNameProps) {\n  return (\n    <div className=\"userName\">\n      <span>{props.user.name} </span>\n      <span className=\"userCount\">\n        (with {props.users.length - 1} other {((props.users.length - 1 === 1) ? \"person\" : \"people\")})\n      </span>\n    </div>\n  )\n}\n\ninterface NoteEditorProps {\n  handleChange: (target: EventTarget) => void;\n  handleCreate: () => void;\n  demo: () => string;\n}\n\nfunction NoteEditor(props: NoteEditorProps) {\n  const onEnterPress = (e) => {\n    if (e.keyCode === 13 && !e.shiftKey) {\n      e.preventDefault();\n      props.handleCreate();\n    }\n  }\n\n  const handleFocus = (e) => {\n    if (!e.target.innerText) {\n      e.target.innerText = props.demo();\n      props.handleChange(e.target);\n    }\n  }\n\n  return (\n    <div className=\"note note-editor\">\n      <div\n        contentEditable\n        className=\"note-text\"\n        onInput={(e) => props.handleChange(e.target)}\n        onKeyDown={onEnterPress}\n        onFocus={handleFocus}\n      />\n    </div>\n  );  \n}\n\ninterface ButtonProps {\n  disabled: boolean;\n  text: string;\n  handleClick: () => void;\n}\n\nexport function Button(props: ButtonProps) {\n  if (props.disabled) {\n    return <button      \n      disabled>{props.text}\n    </button>\n  } else {\n    return <button      \n      onClick={props.handleClick}>\n      {props.text}\n    </button>\n  }\n}\n\ninterface NoteProps {\n  count: number;\n  note: INoteWithVotes;\n  user: IUser;\n  handleClick: (note: INote) => void;\n  highlightMine: boolean;\n}\n\nfunction Note(props: NoteProps) {\n  return (\n    <div\n      className={((props.note.user.id !== props.user.id) && props.highlightMine) ? \"note others\" : \"note\"}\n      onClick={() => props.handleClick(props.note)}>\n      <Badge count={props.count} note={props.note} />\n      <NoteContent note={props.note} />\n    </div>\n  );\n}\n\ninterface NoteContentProps {\n  note: INoteWithVotes;\n}\n\nfunction NoteContent(props: NoteContentProps) {\n  return (\n    <div className=\"note-text\">\n      {props.note.text}\n    </div>\n  );\n}\n\ninterface BadgeProps {\n  count: number;\n  note: INoteWithVotes;\n}\n\nfunction Badge(props: BadgeProps) {\n  let badgeClass = \"note-badge\";\n\n  if (props.note.currentUserVoted) {\n    badgeClass = \"note-badge voted\"\n  }\n\n  if (props.count > 0) {\n    return <div className={badgeClass}>{props.count}</div>\n  } else {\n    return null;\n  }\n}"},"fluidObjects/clicker/clicker.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { \n    DataObject, \n    DataObjectFactory, \n    ContainerRuntimeFactoryWithDefaultDataStore } \nfrom \"@fluidframework/aqueduct\";\n\nimport { IFluidHTMLView } from \"@fluidframework/view-interfaces\";\nimport { SharedCounter } from \"@fluidframework/counter\";\nimport { IFluidHandle } from \"@fluidframework/core-interfaces\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nconst counterKey = \"counter\";\n\n/**\n * Basic Clicker example using new interfaces and stock DataObject classes.\n */\nexport class Clicker extends DataObject implements IFluidHTMLView {\n    public get IFluidHTMLView() {\n        return this;\n    }\n\n    static get DataObjectName() { return \"@fluid-example/clicker\"; }\n\n    private _counter: SharedCounter | undefined;\n\n    static factory = new DataObjectFactory(\n        Clicker.DataObjectName,\n        Clicker,\n        [SharedCounter.getFactory()],\n        {},\n    );\n\n    /**\n     * Do setup work here\n     */\n    protected async initializingFirstTime() {\n        const counter = SharedCounter.create(this.runtime);\n        this.root.set(counterKey, counter.handle);\n    }\n\n    protected async hasInitialized() {\n        const counterHandle = this.root.get<IFluidHandle<SharedCounter>>(counterKey);\n        this._counter = await counterHandle.get();\n    }\n\n    // #region IComponentHTMLView\n\n    /**\n     * Will return a new Clicker view\n     */\n    public render(div: HTMLElement) {\n        // Get our counter object that we set in initialize and pass it in to the view.\n        ReactDOM.render(\n            <CounterReactView counter={this.counter} />,\n            div,\n        );\n        return div;\n    }\n\n    // #endregion IComponentHTMLView\n\n    private get counter() {\n        if (this._counter === undefined) {\n            throw new Error(\"SharedCounter not initialized\");\n        }\n        return this._counter;\n    }\n}\n\n// ----- REACT STUFF -----\n\ninterface CounterProps {\n    counter: SharedCounter;\n}\n\ninterface CounterState {\n    value: number;\n}\n\nclass CounterReactView extends React.Component<CounterProps, CounterState> {\n    constructor(props: CounterProps) {\n        super(props);\n\n        this.state = {\n            value: this.props.counter.value,\n        };\n    }\n\n    componentDidMount() {\n        this.props.counter.on(\"incremented\", (incrementValue: number, currentValue: number) => {\n            this.setState({ value: currentValue });\n        });\n    }\n\n    render() {\n        return (\n            <div>\n                <span style={{fontSize: 30}} className=\"clicker-value-class\" id={`clicker-value-${Date.now().toString()}`}>\n                    {this.state.value}\n                </span>\n                &nbsp;&nbsp;\n                <button style={{fontSize: 20}} onClick={() => { this.props.counter.increment(1); }}>+</button>\n            </div>\n        );\n    }\n}\n\nexport const ClickerContainerFactory = new ContainerRuntimeFactoryWithDefaultDataStore(\n    Clicker.DataObjectName,\n    new Map([[Clicker.DataObjectName, Promise.resolve(Clicker.factory)]])\n  );\n"},"fluidObjects/diceRoller/DiceRoller.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    DataObject, // New Name\n    DataObjectFactory, // New Name\n} from \"@fluidframework/aqueduct\";\nimport { IValueChanged } from \"@fluidframework/map\";\n\nconst diceValueKey = \"diceValueKey\";\n\n/**\n * This is our FluidObject. It contains the logic for interacting with the Fluid Framework.\n */\nexport class DiceRoller extends DataObject {\n    public static get DataObjectName() { return \"@fluid-example/dice-roller\"; }\n\n    /**\n     * The PrimedComponentFactory declares the component and defines any additional distributed data structures.\n     * To add a SharedSequence, SharedMap, or any other structure, put it in the array below.\n     */\n    public static factory = new DataObjectFactory(\n        DiceRoller.DataObjectName,\n        DiceRoller,\n        [],\n        {},\n    );\n\n    /**\n     * componentInitializingFirstTime is called only once, it is executed only by the first client to open the\n     * component and all work will resolve before the view is presented to any user.\n     *\n     * This method is used to perform component setup, which can include setting an initial schema or initial values.\n     */\n    protected async initializingFirstTime() {\n        this.root.set(diceValueKey, 1);\n    }\n\n    protected async hasInitialized() {\n        this.root.on(\"valueChanged\", (changed: IValueChanged) => {\n            if (changed.key === diceValueKey) {\n                this.emit(\"diceRolled\");\n            }\n        });\n    }\n\n    public get id(): string {\n        return this.context.documentId;\n    }\n\n    public get value(): number {\n        return this.root.get(diceValueKey);\n    }\n\n    public readonly roll = () => {\n        const rollValue = Math.floor(Math.random() * 6) + 1;\n        this.root.set(diceValueKey, rollValue);\n    };\n}\n"},"fluidObjects/diceRoller/DiceRollerContainer.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ContainerRuntimeFactoryWithDefaultDataStore } from \"@fluidframework/aqueduct\";\nimport { DiceRoller } from \"./DiceRoller\";\n\n/**\n * This does setup for the Fluid Container. The ContainerRuntimeFactoryWithDefaultComponent also enables\n * dynamic loading in the EmbeddedComponentLoader.\n *\n * There are two important things here:\n * 1. Default Component name\n * 2. Map of string to factory for all components\n *\n * In this example, we are only registering a single component, but more complex examples will register multiple\n * components.\n */\nexport const DiceRollerContainer = new ContainerRuntimeFactoryWithDefaultDataStore(\n    DiceRoller.DataObjectName,\n    new Map([\n        [DiceRoller.DataObjectName, Promise.resolve(DiceRoller.factory)],\n    ]),\n);\n"},"fluidObjects/diceRoller/DiceRollerView.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport React from \"react\";\n\nimport { DiceRoller } from \"./DiceRoller\";\n\ninterface IAppProps {\n    model: DiceRoller;\n}\n\n/**\n * The entirety of the View logic is encapsulated within the App.\n * The App uses the provided model to interact with Fluid.\n */\nexport const DiceRollerView = (props: IAppProps) => {\n    const [diceValue, setDiceValue] = React.useState(props.model.value);\n\n    // Setup a listener that \n    React.useEffect(() => {\n        const onDiceRolled = () => {\n            const newValue = props.model.value;\n            setDiceValue(newValue);\n        };\n        props.model.on(\"diceRolled\", onDiceRolled);\n        return () => {\n            // When the view dismounts remove the listener to avoid memory leaks\n            props.model.off(\"diceRolled\", onDiceRolled);\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [diceValue]);\n\n    // Unicode 0x2680-0x2685 are the sides of a dice ()\n    const diceChar = String.fromCodePoint(0x267F + diceValue);\n    const diceColor = `hsl(${diceValue * 60}, 70%, 50%)`;\n\n    // Set the Tab Title to the dice char because it's cool,\n    // and it makes testing with multiple tabs easier\n    document.title = `${diceChar} - ${props.model.id}`;\n\n    return (\n        <div>\n            <div style={{ fontSize: 200, color: diceColor }}>{diceChar}</div>\n            <button style={{ fontSize: 50, marginLeft: 10 }} onClick={props.model.roll}>Roll</button>\n        </div>\n    );\n};\n"},"fluidObjects/diceRoller/index.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTinyliciousContainer } from \"@fluidframework/get-tinylicious-container\";\nimport { getDefaultObjectFromContainer } from \"@fluidframework/aqueduct\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport { DiceRollerView } from \"./DiceRollerView\";\nimport { DiceRoller } from \"./DiceRoller\";\nimport { DiceRollerContainer } from \"./DiceRollerContainer\";\n\nlet createNew = false;\nif (window.location.hash.length === 0) {\n    createNew = true;\n    window.location.hash = Date.now().toString();\n}\nconst documentId = window.location.hash.substring(1);\n\n/**\n * This is a helper function for loading the page. It's required because getting the Fluid Container\n * requires making async calls.\n */\nasync function start() {\n    // Get the Fluid Container associated with the provided id\n    const container = await getTinyliciousContainer(documentId, DiceRollerContainer, createNew);\n    // Get the Default Object from the Container (DiceRoller)\n    const defaultObject = await getDefaultObjectFromContainer<DiceRoller>(container);\n\n    // Render the content using ReactDOM\n    ReactDOM.render(\n        <DiceRollerView model={defaultObject} />,\n        document.getElementById(\"content\"));\n}\n\nstart().catch((e)=> {\n    console.error(e);\n    console.log(\n        \"%cEnsure you are running the Tinylicious Fluid Server\\nUse:`npm run start:server`\",\n        \"font-size:30px\");\n});\n"},"fluidObjects/diceRollerJS/DiceRoller.js":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    DataObject, \n    DataObjectFactory, \n} from \"@fluidframework/aqueduct\";\n\nconst diceValueKey = \"diceValueKey\";\n\n/**\n * This is our FluidObject. It contains the logic for interacting with the Fluid Framework.\n */\nexport class DiceRoller extends DataObject {\n    static get DataObjectName() { return \"@fluid-example/dice-roller\"; }\n\n    /**\n     * The PrimedComponentFactory declares the component and defines any additional distributed data structures.\n     * To add a SharedSequence, SharedMap, or any other structure, put it in the array below.\n     */\n    static factory = new DataObjectFactory(\n        DiceRoller.DataObjectName,\n        DiceRoller,\n        [],\n        {},\n    );\n\n    /**\n     * componentInitializingFirstTime is called only once, it is executed only by the first client to open the\n     * component and all work will resolve before the view is presented to any user.\n     *\n     * This method is used to perform component setup, which can include setting an initial schema or initial values.\n     */\n    async initializingFirstTime() {\n        this.root.set(diceValueKey, 1);\n    }\n\n    async hasInitialized() {\n        this.root.on(\"valueChanged\", (changed) => {\n            if (changed.key === diceValueKey) {\n                this.emit(\"diceRolled\");\n            }\n        });\n    }\n\n    get id() {\n        return this.context.documentId;\n    }\n\n    get value() {\n        return this.root.get(diceValueKey);\n    }\n\n    roll = () => {\n        const rollValue = Math.floor(Math.random() * 6) + 1;\n        this.root.set(diceValueKey, rollValue);\n    };\n}\n"},"fluidObjects/diceRollerJS/DiceRollerContainer.js":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ContainerRuntimeFactoryWithDefaultDataStore } from \"@fluidframework/aqueduct\";\nimport { DiceRoller } from \"./DiceRoller\";\n\n/**\n * This does setup for the Fluid Container. The ContainerRuntimeFactoryWithDefaultComponent also enables\n * dynamic loading in the EmbeddedComponentLoader.\n *\n * There are two important things here:\n * 1. Default Component name\n * 2. Map of string to factory for all components\n *\n * In this example, we are only registering a single component, but more complex examples will register multiple\n * components.\n */\nexport const DiceRollerContainer = new ContainerRuntimeFactoryWithDefaultDataStore(\n    DiceRoller.DataObjectName,\n    new Map([\n        [DiceRoller.DataObjectName, Promise.resolve(DiceRoller.factory)],\n    ]),\n);\n"},"fluidObjects/diceRollerJS/DiceRollerView.js":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * The entirety of the View logic is encapsulated within the App.\n * The App uses the provided model to interact with Fluid.\n */\n\nexport function DiceRollerView(model, contentDiv) {\n    let diceChar = null;\n    let diceColor = null;\n    let diceRollerDiv = null;\n\n    const onDiceRolled = () => {\n        const diceValue = model.value;\n        // Unicode 0x2680-0x2685 are the sides of a dice ()\n        diceChar = String.fromCodePoint(0x267F + diceValue);\n        diceColor = `hsl(${diceValue * 60}, 70%, 50%)`;\n        updateDOM();\n    };\n\n    const updateDOM = () => {\n        document.title = `${diceChar} - ${model.id}`;\n        // <h1>ID: ${model.id}</h1>\n        let html = `\n            <div style=\"font-size: 200px; color: ${diceColor}\">${diceChar}</div>\n        `;\n        diceRollerDiv.innerHTML = html;\n    }     \n\n    const render = () => {\n        diceRollerDiv = document.createElement('div');\n        contentDiv.appendChild(diceRollerDiv);\n        contentDiv.appendChild(createButton());\n        // Listen for changes to DiceRoller values\n        model.on(\"diceRolled\", onDiceRolled);\n        // Render initial dice value.\n        onDiceRolled();\n    }\n\n    const createButton = () => {\n        let button = document.createElement(\"button\");\n        button.style.fontSize = \"50px\";\n        button.style.marginLeft = \"10px\";\n        button.innerText = \"Roll\";\n        button.addEventListener('click', () => model.roll());\n        return button;\n    }\n\n    return {\n        render\n    };\n}\n\n// DOM class example (if preferred over functions)\n\n// export class DiceRollerView {\n//     // model is our DiceRoller Fluid DataObject\n//     constructor(model, contentDiv) {\n//         this.model = model;\n//         this.diceChar = null;\n//         this.diceColor = null;\n//         this.diceRollerDiv = document.createElement('div');\n//         contentDiv.appendChild(this.diceRollerDiv);\n//         contentDiv.appendChild(this.createButton());\n\n//         // Listen for changes to DiceRoller values\n//         model.on(\"diceRolled\", () => this.onDiceRolled());\n//         // To remove listener\n//         // model.off(\"diceRolled\", this.onDiceRolled);\n//         // Render initial dice value.\n//         this.onDiceRolled();\n//     }\n\n//     onDiceRolled() {\n//         const diceValue = this.model.value;\n//         // Unicode 0x2680-0x2685 are the sides of a dice ()\n//         this.diceChar = String.fromCodePoint(0x267F + diceValue);\n//         this.diceColor = `hsl(${diceValue * 60}, 70%, 50%)`;\n//         this.render();\n//     };\n\n//     render() {\n//         document.title = `${this.diceChar} - ${this.model.id}`;\n//         let html = `\n//             <h1>ID: ${this.model.id}</h1>\n//             <div style=\"font-size: 200px; color: ${this.diceColor}\">${this.diceChar}</div>\n//         `;\n//         this.diceRollerDiv.innerHTML = html;\n//     }     \n\n//     createButton() {\n//         let button = document.createElement(\"button\");\n//         button.style.fontSize = \"50px\";\n//         button.innerText = \"Roll\";\n//         button.addEventListener('click', () => this.model.roll());\n//         return button;\n//     }\n// }\n"},"fluidObjects/diceRollerJS/index.js":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTinyliciousContainer } from \"@fluidframework/get-tinylicious-container\";\nimport { getDefaultObjectFromContainer } from \"@fluidframework/aqueduct\";\nimport { DiceRollerView } from \"./DiceRollerView\";\nimport { DiceRollerContainer } from \"./DiceRollerContainer\";\n// Since this is a single page Fluid application we are generating a new document id\n// if one was not provided\nlet createNew = false;\nif (window.location.hash.length === 0) {\n    createNew = true;\n    window.location.hash = Date.now().toString();\n}\nconst documentId = window.location.hash.substring(1);\n/**\n * This is a helper function for loading the page. It's required because getting the Fluid Container\n * requires making async calls.\n */\nasync function start() {\n    // Get the Fluid Container associated with the provided id\n    const container = await getTinyliciousContainer(documentId, DiceRollerContainer, createNew);\n    // Get the Default Object from the Container (DiceRoller)\n    const defaultObject = await getDefaultObjectFromContainer(container);\n    // Render the content using standard JavaScript/HTML\n    let diceRollerView = new DiceRollerView(defaultObject, document.getElementById(\"content\"));\n    diceRollerView.render();\n    // Setting \"fluidStarted\" is just for our test automation\n    // eslint-disable-next-line dot-notation\n    window[\"fluidStarted\"] = true;\n}\nstart().catch((e)=> {\n    console.error(e);\n    console.log(\n        \"%cEnsure you are running the Tinylicious Fluid Server\\nUse:`npm run start:server`\",\n        \"font-size:30px\");\n});"},"fluidObjects/draft-js/app.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTinyliciousContainer } from \"@fluidframework/get-tinylicious-container\";\nimport { getDefaultObjectFromContainer } from \"@fluidframework/aqueduct\";\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport { FluidDraftJsObject } from \"./fluid-object\";\nimport { FluidDraftJsContainer } from \"./container\";\nimport { FluidDraftJsView } from \"./view\";\n\n// Since this is a single page fluid application we are generating a new document id\n// if one was not provided\nlet createNew = false;\nif (window.location.hash.length === 0) {\n    createNew = true;\n    window.location.hash = Date.now().toString();\n}\nconst documentId = window.location.hash.substring(1);\n\n/**\n * This is a helper function for loading the page. It's required because getting the Fluid Container\n * requires making async calls.\n */\nasync function start() {\n    // Get the Fluid Container associated with the provided id\n    const container = await getTinyliciousContainer(documentId, FluidDraftJsContainer, createNew);\n\n    // Get the Default Object from the Container\n    const defaultObject = await getDefaultObjectFromContainer<FluidDraftJsObject>(container);\n\n    // Render the content using ReactDOM\n    ReactDOM.render(\n        <FluidDraftJsView model={defaultObject} />,\n        document.getElementById(\"content\"));\n\n    // Setting \"fluidStarted\" is just for our test automation\n    // eslint-disable-next-line dot-notation\n    window[\"fluidStarted\"] = true;\n}\n\nstart().catch((e) => {\n    console.error(e);\n    console.log(\n        \"%cEnsure you are running the Tinylicious Fluid Server\\nUse:`npm run start:server`\",\n        \"font-size:30px\");\n});\n"},"fluidObjects/draft-js/container.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    ContainerRuntimeFactoryWithDefaultDataStore,\n} from \"@fluidframework/aqueduct\";\n\nimport { FluidDraftJsObject } from \"./fluid-object\";\n\n/**\n * This does setup for the Fluid Container.\n *\n * There are two important things here:\n * 1. Default FluidObject name\n * 2. Map of string to factory for all FluidObjects\n *\n * In this example, we are only registering a single FluidObject, but more complex examples will register multiple\n * FluidObjects.\n */\nexport const FluidDraftJsContainer = new ContainerRuntimeFactoryWithDefaultDataStore(\n    FluidDraftJsObject.Name,\n    new Map([FluidDraftJsObject.factory.registryEntry]),\n);\n"},"fluidObjects/draft-js/fluid-object/FluidDraftJs.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    DataObject,\n    DataObjectFactory,\n} from \"@fluidframework/aqueduct\";\nimport { ISequencedClient } from \"@fluidframework/protocol-definitions\";\nimport { SharedMap } from \"@fluidframework/map\";\nimport { SharedString } from \"@fluidframework/sequence\";\nimport { insertBlockStart, PresenceManager } from \"../utils\";\nexport interface IFluidDraftJsObject {\n    text: SharedString | undefined;\n    authors: SharedMap | undefined;\n    readonly presenceManager: PresenceManager;\n    readonly members: IterableIterator<[string, ISequencedClient]>\n    on(event: \"addMember\" | \"removeMember\", listener: () => void): this;\n}\n\nconst addMemberValue = \"addMember\";\nconst removeMemberValue = \"removeMember\";\n\nexport class FluidDraftJsObject extends DataObject implements IFluidDraftJsObject {\n    public static get Name() { return \"@fluid-example/draft-js\"; }\n\n    public text: SharedString | undefined;\n    public authors: SharedMap | undefined;\n    public presenceManager: PresenceManager;\n\n    public static readonly factory = new DataObjectFactory(\n        FluidDraftJsObject.Name,\n        FluidDraftJsObject,\n        [SharedMap.getFactory(), SharedString.getFactory()],\n        {},\n    );\n\n    /**\n     * Do setup work here\n     */\n    protected async initializingFirstTime() {\n        const text = SharedString.create(this.runtime);\n        insertBlockStart(text, 0);\n        text.insertText(text.getLength(), \"starting text\");\n        this.root.set(\"text\", text.handle);\n\n        const authors = SharedMap.create(this.runtime);\n        this.root.set(\"authors\", authors.handle);\n    }\n\n    protected async hasInitialized() {\n        [this.text, this.authors] = await Promise.all([this.root.get(\"text\").get(), this.root.get(\"authors\").get()]);\n\n        // this.presenceManager = new PresenceManager(this.authors, this.runtime);\n        this.runtime.getQuorum().on(addMemberValue, () => {\n            this.emit(addMemberValue);\n        });\n        this.runtime.getQuorum().on(removeMemberValue, () => {\n            this.emit(removeMemberValue);\n        });\n\n        this.presenceManager = new PresenceManager(this.authors, this.runtime);\n    }\n\n    public get members() {\n        return this.runtime.getQuorum().getMembers().entries();\n    }\n}\n"},"fluidObjects/draft-js/fluid-object/index.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport * from \"./FluidDraftJs\";\n"},"fluidObjects/draft-js/index.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport * from \"./container\";\nexport * from \"./fluid-object\";\nexport * from \"./view\";\n"},"fluidObjects/draft-js/utils/Presence.css":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n.presence-cursor {\n    display: inline;\n    position: relative;\n}\n\n.presence-cursor::after {\n    content: \" \";\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 1.1px;\n    background-color: inherit;\n    height: 1em;\n}\n"},"fluidObjects/draft-js/utils/PresenceManager.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport React from \"react\";\n\nimport { SharedMap } from \"@fluidframework/map\";\nimport { ISequencedDocumentMessage } from \"@fluidframework/protocol-definitions\";\nimport { IFluidDataStoreRuntime } from \"@fluidframework/datastore-definitions\";\nimport { CharacterMetadata, CompositeDecorator, ContentBlock } from \"draft-js\";\nimport { List } from \"immutable\";\n\nimport { getColorForMember } from \"../view\";\nimport { BlockTextRange, TextRange, textRangeToBlockTextRangeFromBlocks } from \"./RichTextAdapter\";\n\n// eslint-disable-next-line import/no-unassigned-import\nimport \"./Presence.css\";\n\ninterface Author {\n    id: string;\n    color: string;\n    pos: TextRange | undefined;\n}\n\ninterface AuthorWithBlockRange extends Author {\n    blockRange: BlockTextRange;\n}\n\nconst maxPos = { start: Number.MAX_SAFE_INTEGER, end: Number.MAX_SAFE_INTEGER };\nconst entityPrefix = \"presence-\";\nconst placeholderChar = \"\\u200B\"; // Zero width space\n\nexport class PresenceManager {\n    private readonly coauthorPositions: Map<string, Author> = new Map<string, Author>();\n\n    public constructor(private readonly authorMap: SharedMap, private readonly runtime: IFluidDataStoreRuntime) { }\n\n    public subscribe(renderCallback: (textRangeUpdater: (range: TextRange) => TextRange) => void) {\n        this.authorMap.on(\"op\", (op: ISequencedDocumentMessage, local: boolean) => {\n            if (local || op.contents.key === this.runtime.clientId) {\n                return;\n            }\n\n            let oldValue = this.coauthorPositions.get(op.contents.key);\n            if (oldValue === undefined) {\n                oldValue = {\n                    id: \"\",\n                    color: \"\",\n                    pos: undefined,\n                };\n            }\n            const newValue = { ...oldValue, pos: undefined };\n\n            if (op.contents.type === \"delete\") {\n                this.coauthorPositions.delete(op.contents.key);\n            } else {\n                newValue.id = op.contents.key;\n                newValue.pos = op.contents.value.value;\n                if (!newValue.color) {\n                    const sequencedClient = this.runtime.getQuorum().getMember(op.clientId);\n                    newValue.color = getColorForMember(sequencedClient);\n                }\n                this.coauthorPositions.set(op.contents.key, newValue);\n            }\n\n            const newPos = newValue.pos || maxPos;\n            const oldPos = oldValue.pos || maxPos;\n            const textRangeUpdater = (range: TextRange) => {\n                if (oldPos.start < range.start && newPos.start >= range.start) {\n                    range.start--;\n                } else if (oldPos.start >= range.start && newPos.start < range.start) {\n                    range.start++;\n                }\n                if (oldPos.start < range.end && newPos.start >= range.end) {\n                    range.end--;\n                } else if (oldPos.start >= range.end && newPos.start < range.end) {\n                    range.end++;\n                }\n                return range;\n            };\n\n            renderCallback(textRangeUpdater);\n        });\n\n        window.onbeforeunload = () => {\n            this.authorMap.delete(this.runtime.clientId);\n        };\n    }\n\n    public publish(currentPosition: TextRange | undefined) {\n        this.authorMap.set(this.runtime.clientId, currentPosition);\n    }\n\n    public addPresencePlaceholders(blocks: ContentBlock[]): ContentBlock[] {\n        const coauthByBlock = new Map<string, AuthorWithBlockRange[]>();\n        this.coauthorPositions.forEach((author, k) => {\n            if (author.pos !== undefined) {\n                const blockRange = textRangeToBlockTextRangeFromBlocks(author.pos, blocks);\n                if (!coauthByBlock.has(blockRange.startKey)) {\n                    coauthByBlock.set(blockRange.startKey, [{ ...author, blockRange }]);\n                } else {\n                    coauthByBlock.get(blockRange.startKey).push({ ...author, blockRange });\n                }\n            }\n        });\n\n        return blocks.map((block) => {\n            if (!coauthByBlock.has(block.getKey())) {\n                return block;\n            }\n\n            let text = block.getText();\n            const characterList = block.getCharacterList().toArray();\n\n            const offsetsReverse = coauthByBlock\n                .get(block.getKey())\n                .sort((a, b) => b.blockRange.startOffset - a.blockRange.startOffset);\n            for (const abr of offsetsReverse) {\n                const index = abr.blockRange.startOffset;\n                text = `${text.slice(0, index)}${placeholderChar}${text.slice(index)}`;\n                characterList.splice(index, 0, CharacterMetadata.create({ entity: `${entityPrefix}${abr.id}` }));\n            }\n\n            return new ContentBlock({\n                key: block.getKey(),\n                type: block.getType(),\n                text,\n                characterList: List.of<CharacterMetadata>(...characterList),\n            });\n        });\n    }\n\n    public removePlaceholderChars(text: string) {\n        return text.replace(new RegExp(placeholderChar, \"g\"), \"\");\n    }\n\n    public subtractCoauthorPlaceholders(range: TextRange): TextRange {\n        this.coauthorPositions.forEach((author) => {\n            if (author.pos && author.pos.start < range.start) {\n                range.start--;\n            }\n            if (author.pos && author.pos.start < range.end) {\n                range.end--;\n            }\n        });\n        return range;\n    }\n\n    public getAuthorColor(authorId: string): string {\n        const author = this.coauthorPositions.get(authorId);\n        return author ? author.color : \"\";\n    }\n}\n\nconst findPresencePlaceholderStrategy = (block: ContentBlock, callback: (start: number, end: number) => void): void => {\n    block.getCharacterList().forEach((char, index) => {\n        if (char.getEntity() && char.getEntity().startsWith(entityPrefix)) {\n            callback(index, index + 1);\n        }\n    });\n};\n\nexport const getCoauthPresenceDecorator = (presenceManager: PresenceManager) => {\n    const CoauthorIndicator = (props) => {\n        let authorId;\n        if (props.entityKey.startsWith(entityPrefix)) {\n            authorId = props.entityKey.substring(entityPrefix.length);\n        }\n        // Replace the placeholder char with some UI If this block is empty (except for the placeholder char) add a\n        // <br /> after because that's what Draft does to preserve spacing in empty blocks, and we're turning this into\n        // an empty block by removing the placeholder.\n        return <>\n            <span style={{ backgroundColor: presenceManager.getAuthorColor(authorId) }} className=\"presence-cursor\" />\n            {props.start === 0 && props.contentState.getBlockForKey(props.blockKey).getLength() === 1 ? <br /> : null}\n        </>;\n    };\n\n    return new CompositeDecorator([\n        {\n            strategy: findPresencePlaceholderStrategy,\n            component: CoauthorIndicator,\n        },\n    ]);\n};\n"},"fluidObjects/draft-js/utils/RichTextAdapter.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    ISegment,\n    Marker,\n    MergeTreeDeltaType,\n    ReferenceType,\n    reservedMarkerIdKey,\n    TextSegment,\n} from \"@fluidframework/merge-tree\";\nimport { ISequenceDeltaRange, SharedString } from \"@fluidframework/sequence\";\nimport { CharacterMetadata, ContentBlock, ContentState, genKey, SelectionState } from \"draft-js\";\nimport { List, OrderedSet } from \"immutable\";\n\nexport const insertBlockStart = (\n    text: SharedString,\n    pos: number,\n    key: string = genKey(),\n    type: string = \"unstyled\",\n): void => {\n    text.insertMarker(pos, ReferenceType.RangeBegin, {\n        [reservedMarkerIdKey]: key,\n        blockType: type,\n    });\n};\n\nexport interface TextRange {\n    start: number;\n    end: number;\n}\n\nexport interface BlockTextRange {\n    startKey: string;\n    startOffset: number;\n    endKey: string;\n    endOffset: number;\n}\n\nconst draftTextStyleNames = new Set([\"BOLD\", \"ITALIC\", \"UNDERLINE\", \"CODE\"]);\n\nexport const draftStyleToSharedTextProp = (formats: OrderedSet<string>, styleName?: string): {} => {\n    const prop = {};\n    if (styleName === undefined) {\n        for (const style of draftTextStyleNames) {\n            prop[style] = formats.has(style) ? true : null;\n        }\n    } else if (draftTextStyleNames.has(styleName.toUpperCase())) {\n        const style = styleName.toUpperCase();\n        prop[style] = formats.has(style);\n    } else {\n        throw new Error(`Unknown style name ${styleName}`);\n    }\n    return prop;\n};\n\nconst sharedTextStylePropToDraft = (prop: {}): OrderedSet<string> => {\n    const result = [];\n    for (const styleName of draftTextStyleNames) {\n        if (prop[styleName] === true) {\n            result.push(styleName);\n        }\n    }\n\n    return OrderedSet.of<string>(...result);\n};\n\nexport const selectionToBlockRange = (selection: SelectionState): BlockTextRange => ({\n    startKey: selection.getStartKey(),\n    startOffset: selection.getStartOffset(),\n    endKey: selection.getEndKey(),\n    endOffset: selection.getEndOffset(),\n});\n\nexport const blockRangeToSelection = (range: BlockTextRange, hasFocus: boolean): SelectionState => new SelectionState({\n    anchorKey: range.startKey,\n    anchorOffset: range.startOffset,\n    focusKey: range.endKey,\n    focusOffset: range.endOffset,\n    hasFocus,\n});\n\nexport const textRangeToBlockTextRangeFromBlocks = (absPos: TextRange, blocks: ContentBlock[]): BlockTextRange => {\n    const contentPos = { startKey: undefined, startOffset: 0, endKey: undefined, endOffset: 0 };\n\n    let prevEnd = 0;\n    for (const block of blocks) {\n        prevEnd++;\n        if (contentPos.startKey === undefined && absPos.start <= prevEnd + block.getLength()) {\n            contentPos.startKey = block.getKey();\n            contentPos.startOffset = absPos.start - prevEnd;\n        }\n        if (absPos.end <= prevEnd + block.getLength()) {\n            contentPos.endKey = block.getKey();\n            contentPos.endOffset = absPos.end - prevEnd;\n            break;\n        }\n        prevEnd = prevEnd + block.getLength();\n    }\n\n    if (contentPos.endKey === undefined) {\n        contentPos.endKey = blocks[blocks.length - 1].getKey();\n        contentPos.endOffset = blocks[blocks.length - 1].getLength();\n    }\n    if (contentPos.startKey === undefined) {\n        contentPos.startKey = contentPos.endKey;\n        contentPos.startOffset = contentPos.endOffset;\n    }\n\n    return contentPos;\n};\n\n/**\n * Convert delta range to blocks and offsets\n * @param start Absolute position of start of the range\n * @param end Absolute position of the end of the range\n * @param content The ConstentState of the editor\n */\nexport const textRangeToBlockTextRange =\n    (absPos: TextRange, content: ContentState): BlockTextRange =>\n        textRangeToBlockTextRangeFromBlocks(absPos, content.getBlocksAsArray());\n\n/**\n * Convert a DraftJS selection to a SharedString TextRange\n */\nexport const selectionToTextRange = (selection: SelectionState, content: ContentState): TextRange => {\n    const position: TextRange = { start: 0, end: undefined };\n    const range = selectionToBlockRange(selection);\n\n    const blocks = content.getBlocksAsArray();\n    let prevEnd = 0;\n    for (const block of blocks) {\n        prevEnd++;\n        if (block.getKey() === range.startKey) {\n            position.start = prevEnd + range.startOffset;\n        }\n        if (block.getKey() === range.endKey) {\n            position.end = prevEnd + range.endOffset;\n            break;\n        }\n\n        prevEnd = prevEnd + block.getLength();\n    }\n\n    if (position.end === undefined) {\n        position.end = prevEnd;\n    }\n\n    return position;\n};\n\nexport const sharedStringToBlockArary = (sharedString: SharedString): ContentBlock[] => {\n    const blocks = [];\n    let currentBlock: any = { key: undefined, text: \"\" };\n\n    let characterList = [];\n    sharedString.walkSegments((segment: ISegment) => {\n        if (segment.type === \"Marker\") {\n            const markerSegment = segment as Marker;\n            if (\n                markerSegment.refType === ReferenceType.RangeBegin &&\n                markerSegment.properties !== undefined &&\n                markerSegment.properties[reservedMarkerIdKey] !== undefined\n            ) {\n                if (currentBlock.key !== undefined) {\n                    blocks.push(\n                        new ContentBlock({\n                            ...currentBlock,\n                            characterList: List.of<CharacterMetadata>(...characterList),\n                        }),\n                    );\n                }\n\n                currentBlock = {\n                    key: markerSegment.properties[reservedMarkerIdKey],\n                    type: markerSegment.properties.blockType,\n                    text: \"\",\n                };\n                characterList = [];\n            }\n        } else if (segment.type === \"TextSegment\") {\n            const textSegment = segment as TextSegment;\n\n            const metaConfig: any = {};\n            if (textSegment.properties !== undefined) {\n                metaConfig.style = sharedTextStylePropToDraft(textSegment.properties);\n            }\n\n            const meta = CharacterMetadata.create(metaConfig);\n            characterList = characterList.concat(new Array(textSegment.cachedLength).fill(meta));\n            currentBlock.text += textSegment.text;\n        }\n        return true;\n    }, 0, sharedString.getLength());\n\n    blocks.push(\n        new ContentBlock({\n            ...currentBlock,\n            characterList: List.of<CharacterMetadata>(...characterList),\n        }),\n    );\n    return blocks;\n};\n\nexport const getMarkersInBlockRange = (sharedString: SharedString, startKey: string, endKey: string): Marker[] => {\n    const markers = [];\n\n    let enteredRange = false;\n    let exitedRange = false;\n    sharedString.walkSegments((segment: ISegment) => {\n        if (\n            !exitedRange &&\n            segment.type === \"Marker\" &&\n            segment.properties !== undefined &&\n            segment.properties[reservedMarkerIdKey] !== undefined\n        ) {\n            if (segment.properties[reservedMarkerIdKey] === startKey) {\n                enteredRange = true;\n            }\n            if (enteredRange) {\n                markers.push(segment);\n            }\n            if (segment.properties[reservedMarkerIdKey] === endKey) {\n                exitedRange = true;\n            }\n        }\n        return true;\n    }, 0, sharedString.getLength());\n\n    return markers;\n};\n\n/**\n * Update a text range to reflect changes in the surrounding text\n */\nexport const updateTextRange = (\n    opRanges: readonly Readonly<ISequenceDeltaRange>[],\n    textRange: TextRange,\n): TextRange => {\n    const updatedRange = { ...textRange };\n\n    for (const delta of opRanges) {\n        if (delta.operation === MergeTreeDeltaType.INSERT) {\n            if (delta.position <= updatedRange.start) {\n                updatedRange.start += delta.segment.cachedLength;\n                updatedRange.end += delta.segment.cachedLength;\n            } else if (delta.position < updatedRange.end) {\n                updatedRange.end += delta.segment.cachedLength;\n            }\n        } else if (delta.operation === MergeTreeDeltaType.REMOVE) {\n            if (delta.position < updatedRange.start) {\n                updatedRange.start -= delta.segment.cachedLength;\n                updatedRange.end -= delta.segment.cachedLength;\n            } else if (delta.position < updatedRange.end) {\n                updatedRange.end -= Math.min(delta.segment.cachedLength, updatedRange.end - delta.position);\n            }\n        }\n    }\n    return updatedRange;\n};\n"},"fluidObjects/draft-js/utils/index.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport * from \"./PresenceManager\";\nexport * from \"./RichTextAdapter\";\n"},"fluidObjects/draft-js/view/FluidDraftJsView.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport React from \"react\";\nimport { ISequencedDocumentMessage } from \"@fluidframework/protocol-definitions\";\n\nimport { FluidDraftJsObject, IFluidDraftJsObject } from \"../fluid-object\";\nimport { MemberList } from \"./MemberList\";\nimport { FluidEditor } from \"./FluidEditor\";\n\ninterface IAppProps {\n    model: FluidDraftJsObject;\n}\n\n/**\n * The entirety of the View logic is encapsulated within the App.\n * The App uses the provided model to interact with Fluid.\n */\nexport const FluidDraftJsView: React.FC<IAppProps> = (props) => {\n    const [members, setMembers] = React.useState<IFluidDraftJsObject[\"members\"]>(props.model.members);\n\n    React.useEffect(() => {\n        const onMembersChange = () => {\n            setMembers(props.model.members);\n        };\n        props.model.on(\"addMember\", onMembersChange);\n        props.model.on(\"removeMember\", onMembersChange);\n        return () => {\n            // When the view dismounts remove the listener to avoid memory leaks\n            props.model.off(\"addMember\", onMembersChange);\n            props.model.off(\"removeMember\", onMembersChange);\n        };\n    }, [props.model]);\n\n    const onNewAuthor = (callback: (op: ISequencedDocumentMessage, isLocal) => void) => {\n        const func = (op: ISequencedDocumentMessage, isLocal: boolean) => callback(op, isLocal);\n        props.model.authors.on(\"op\", func);\n    };\n\n    return (\n        <div style={{ margin: \"20px auto\", maxWidth: 800 }}>\n            <MemberList members={members} onNewAuthor={onNewAuthor} style={{ textAlign: \"right\" }} />\n            <FluidEditor\n                sharedString={props.model.text}\n                authors={props.model.authors}\n                presenceManager={props.model.presenceManager}\n            />\n        </div>\n    );\n};\n"},"fluidObjects/draft-js/view/FluidEditor.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { SharedMap } from \"@fluidframework/map\";\nimport { SequenceDeltaEvent, SharedString } from \"@fluidframework/sequence\";\nimport { ContentState, Editor, EditorProps, EditorState, RichUtils } from \"draft-js\";\nimport React from \"react\";\nimport {\n    blockRangeToSelection,\n    draftStyleToSharedTextProp,\n    getMarkersInBlockRange,\n    insertBlockStart,\n    selectionToTextRange,\n    sharedStringToBlockArary,\n    TextRange,\n    textRangeToBlockTextRange,\n    updateTextRange,\n    getCoauthPresenceDecorator,\n    PresenceManager,\n} from \"../utils\";\nimport { BlockStyleControls, InlineStyleControls } from \"./StyleControls\";\n\n// eslint-disable-next-line import/no-internal-modules, import/no-unassigned-import\nimport \"./css/RichEditor.css\";\n\ninterface IProps extends Partial<EditorProps> {\n    sharedString: SharedString;\n    authors: SharedMap;\n    presenceManager: PresenceManager;\n}\n\ninterface IState {\n    editorState: EditorState;\n}\n\nexport { IProps as IFluidEditorProps };\nexport { IState as IFluidEditorState };\n\nconst styleMap = {\n    CODE: {\n        backgroundColor: \"rgba(0, 0, 0, 0.05)\",\n        fontFamily: '\"Inconsolata\", \"Menlo\", \"Consolas\", monospace',\n        fontSize: 16,\n        padding: 2,\n    },\n};\n\nconst getBlockStyle = (block) => {\n    switch (block.getType()) {\n        case \"blockquote\":\n            return \"RichEditor-blockquote\";\n        case \"unstyled\":\n            return \"RichEditor-paragraph\";\n        default:\n            return null;\n    }\n};\n\n/**\n * A wrapper around the Draft.js Editor which connects RichUtils and callbacks to connect Fluid\n */\nexport class FluidEditor extends React.Component<IProps, IState> {\n    constructor(props: IProps) {\n        super(props);\n\n        const contentState = ContentState.createFromBlockArray(sharedStringToBlockArary(this.props.sharedString));\n        let editorState = EditorState.createWithContent(contentState);\n\n        editorState = EditorState.set(editorState, {\n            decorator: getCoauthPresenceDecorator(this.props.presenceManager),\n        });\n\n        this.state = {\n            editorState,\n        };\n    }\n\n    private readonly updateEditorState = (updateSelectionRange: (range: TextRange) => TextRange): void => {\n        let blocks = sharedStringToBlockArary(this.props.sharedString);\n        blocks = this.props.presenceManager.addPresencePlaceholders(blocks);\n        const newContent = ContentState.createFromBlockArray(blocks);\n        let editorState = EditorState.push(this.state.editorState, newContent, \"change-block-data\");\n\n        let selection = this.state.editorState.getSelection();\n        if (selection.getHasFocus()) {\n            let selectionTextRange = selectionToTextRange(selection, this.state.editorState.getCurrentContent());\n            selectionTextRange = updateSelectionRange(selectionTextRange);\n            const updatedBlockRange = textRangeToBlockTextRange(selectionTextRange, editorState.getCurrentContent());\n            selection = blockRangeToSelection(updatedBlockRange, selection.getHasFocus());\n            editorState = EditorState.forceSelection(editorState, selection);\n        }\n\n        this.setState({ editorState });\n    };\n\n    componentDidMount() {\n        // Give everything a moment to render before rushing into rendering coauth positions.\n        setTimeout(() => {\n            this.props.presenceManager.subscribe(this.updateEditorState);\n        }, 200);\n    }\n\n    // eslint-disable-next-line react/no-deprecated\n    componentWillMount() {\n        this.props.sharedString.on(\"sequenceDelta\", (event: SequenceDeltaEvent) => {\n            try {\n                // We've already rendered local changes.\n                if (event.isLocal) {\n                    return;\n                }\n\n                const updateSelectionRange = (textRange: TextRange) => updateTextRange(event.ranges, textRange);\n                this.updateEditorState(updateSelectionRange);\n            } catch (exception) {\n                console.error(exception);\n                debugger;\n            }\n        });\n    }\n\n    private readonly onChange = (editorState: EditorState, changedStyle?: string) => {\n        // Store some important variables so we can use them later.\n        const newContent = editorState.getCurrentContent();\n        // Represent each block marker prefix as a newline, remove presence placeholders\n        const newText = `\\n${this.props.presenceManager.removePlaceholderChars(newContent.getPlainText())}`;\n        const newSelection = editorState.getSelection();\n\n        const oldContent = this.state.editorState.getCurrentContent();\n        const oldSelection = this.state.editorState.getSelection();\n\n        if (newSelection !== oldSelection) {\n            const publishedPosition = newSelection.getHasFocus()\n                ? this.props.presenceManager.subtractCoauthorPlaceholders(\n                    selectionToTextRange(newSelection, newContent),\n                )\n                : undefined;\n            this.props.presenceManager.publish(publishedPosition);\n        }\n\n        if (newContent !== oldContent) {\n            let { start, end } = this.props.presenceManager.subtractCoauthorPlaceholders(\n                selectionToTextRange(oldSelection, oldContent),\n            );\n\n            const changeType = editorState.getLastChangeType();\n            if (changeType === \"insert-characters\" || changeType === \"insert-fragment\") {\n                const newSelectionAbsolute = this.props.presenceManager.subtractCoauthorPlaceholders(\n                    selectionToTextRange(newSelection, newContent),\n                );\n                const insertedText = newText.substring(start, newSelectionAbsolute.end);\n\n                if (insertedText.includes(\"\\n\")) {\n                    debugger; // TODO Can you paste newlines?\n                }\n\n                const styleProp = draftStyleToSharedTextProp(editorState.getCurrentInlineStyle());\n                if (end - start) {\n                    // If there are selected characters we need to replace\n                    this.props.sharedString.replaceText(start, end, insertedText, styleProp);\n                } else {\n                    // Text was simply inserted\n                    this.props.sharedString.insertText(start, insertedText, styleProp);\n                }\n            } else if (\n                changeType === \"delete-character\" ||\n                changeType === \"remove-range\" ||\n                changeType === \"backspace-character\"\n            ) {\n                if (changeType === \"delete-character\") {\n                    end++;\n                } else if (changeType === \"backspace-character\") {\n                    start--;\n                }\n                this.props.sharedString.removeText(start, end);\n            } else if (changeType === \"split-block\") {\n                const newBlock = newContent.getBlockAfter(oldSelection.getEndKey());\n                insertBlockStart(this.props.sharedString, start, newBlock.getKey(), newBlock.getType());\n            } else if (changeType === \"change-inline-style\") {\n                if (!changedStyle) {\n                    throw new Error(\"Expected changedStyle to be set for style changes\");\n                }\n                const styleProp = draftStyleToSharedTextProp(editorState.getCurrentInlineStyle(), changedStyle);\n                this.props.sharedString.annotateRange(start, end, styleProp);\n            } else if (changeType === \"change-block-type\") {\n                const markers = getMarkersInBlockRange(\n                    this.props.sharedString,\n                    oldSelection.getStartKey(),\n                    oldSelection.getEndKey(),\n                );\n                const newType = newContent.getBlockForKey(oldSelection.getStartKey()).getType();\n                for (const marker of markers) {\n                    this.props.sharedString.annotateMarker(marker, { blockType: newType });\n                }\n            } else if (changeType === \"undo\" || changeType === \"redo\") {\n                /**\n                 * TODO Not yet implemented There are two issues here:\n                 *\n                 *  1. We need syncs from coauthors to be excluded from the undo stack (they currently aren't)\n                 *  2. We need to convert the undo/redo events into some kind of diff that can be applied to the\n                 *     SharedString For now, force the selection back to how it was and ignore the event\n                 */\n                this.setState({\n                    editorState: EditorState.acceptSelection(\n                        this.state.editorState, this.state.editorState.getSelection()),\n                });\n                return;\n            }\n        }\n\n        // If nothing has changed there might have been something minor so we still want to update the editorState.\n        this.setState({ editorState });\n    };\n\n    private readonly handleKeyCommand = (command, editorState) => {\n        const newState = RichUtils.handleKeyCommand(editorState, command);\n        if (newState) {\n            this.onChange(newState, command);\n            return \"handled\";\n        }\n        return \"not-handled\";\n    };\n\n    private readonly toggleInlineStyle = (inlineStyle: string) => {\n        this.onChange(RichUtils.toggleInlineStyle(this.state.editorState, inlineStyle), inlineStyle);\n    };\n\n    private readonly toggleBlockType = (blockType) => {\n        this.onChange(RichUtils.toggleBlockType(this.state.editorState, blockType));\n    };\n\n    render() {\n        // TODO Pass through props to Editor\n        return (\n            <div className=\"RichEditor-root\">\n                <div className=\"RichEditor-toolbar\">\n                    <InlineStyleControls editorState={this.state.editorState} onToggle={this.toggleInlineStyle} />\n                    <BlockStyleControls editorState={this.state.editorState} onToggle={this.toggleBlockType} />\n                </div>\n                <div className=\"RichEditor-editor\">\n                    <Editor\n                        editorState={this.state.editorState}\n                        onChange={this.onChange}\n                        handleKeyCommand={this.handleKeyCommand}\n                        blockStyleFn={getBlockStyle}\n                        customStyleMap={styleMap}\n                    />\n                </div>\n            </div>\n        );\n    }\n}\n"},"fluidObjects/draft-js/view/MemberList.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ISequencedClient } from \"@fluidframework/protocol-definitions\";\nimport React from \"react\";\n\n// eslint-disable-next-line import/no-internal-modules, import/no-unassigned-import\nimport \"./css/MemberList.css\";\n\ninterface IProps {\n    /**\n   * Any Distributed Data Structure that users will interact with. A user is not shown in the\n   * member list until the have touched this DDS.\n   */\n    members: IterableIterator<[string, ISequencedClient]>;\n    /**\n   * Callback for when an a new author is added\n   */\n    onNewAuthor: (func: (op, isLocal) => void) => void;\n    style?: React.CSSProperties;\n}\n\ninterface MemberInfo {\n    color: string;\n    name: string;\n    initials: string;\n    id: string;\n}\n\ninterface IState {\n    members: MemberInfo[];\n}\n\nexport { IProps as IMemberListProps };\n\n/**\n * Get a semi-random, but deterministic, color for a given client\n */\nexport const getColorForMember = (sc: ISequencedClient) => {\n    // Support 20 unique colors\n    const colorNumber = sc.sequenceNumber % 20;\n    // Spread them through the hue range with an overflow so the first few authors are likely\n    // to have very different colors\n    return `hsl(${(colorNumber * 360 / 7) % 360}, 100%, 35%)`;\n};\n\n/**\n * A generic component which shows a list of authors as colored circles with initials.\n * @see getColorForMember to use the same color in other UI for each author\n */\nexport class MemberList extends React.Component<IProps, IState> {\n    private readonly knownHumanMemberIds = new Set<string>();\n\n    public constructor(props: IProps) {\n        super(props);\n        this.state = {\n            members: [],\n        };\n    }\n\n    // eslint-disable-next-line react/no-deprecated\n    public componentWillMount() {\n        this.updateMemberList();\n        this.props.onNewAuthor((op, isLocal) => {\n            if (!isLocal && !this.knownHumanMemberIds.has(op.clientId)) {\n                this.knownHumanMemberIds.add(op.clientId);\n                this.updateMemberList();\n            }\n        });\n    }\n\n    private readonly updateMemberList = () => {\n        const members = Array.from(\n            this.props.members,\n        )\n            .filter(([id, _]) => this.knownHumanMemberIds.has(id))\n            .map(([id, sc]) => {\n                let name: string = (sc.client.user as any).displayName || (sc.client.user as any).name;\n                let initials: string;\n                if (name) {\n                    const nameWords = name.replace(\"_\", \" \").split(\" \");\n                    initials = nameWords[0][0].toUpperCase();\n                    if (nameWords.length > 1) {\n                        initials += nameWords[nameWords.length - 1][0].toUpperCase();\n                    }\n                } else {\n                    name = sc.client.user.id.substring(0, 5);\n                    initials = name.substring(0, 2);\n                }\n\n                return {\n                    name,\n                    initials,\n                    color: getColorForMember(sc),\n                    id,\n                };\n            });\n        this.setState({ members });\n    };\n\n    public render() {\n        return (\n            <div className=\"memberList\" style={this.props.style}>\n                {this.state.members.map((memberInfo) => (\n                    <div\n                        className=\"memberIcon\"\n                        key={memberInfo.id}\n                        style={{ backgroundColor: memberInfo.color }}\n                        title={memberInfo.name}\n                    >\n                        {memberInfo.initials}\n                    </div>\n                ))}\n            </div>\n        );\n    }\n}\n"},"fluidObjects/draft-js/view/StyleControls.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport React from \"react\";\n\ninterface IProps {\n    active: boolean;\n    label: string;\n    onToggle: any;\n    style: string;\n}\n\nclass StyleButton extends React.Component<IProps> {\n    private readonly onToggle = (e) => {\n        e.preventDefault();\n        this.props.onToggle(this.props.style);\n    };\n\n    render() {\n        let className = \"RichEditor-styleButton\";\n        if (this.props.active) {\n            className += \" RichEditor-activeButton\";\n        }\n        return (\n            <span className={className} onMouseDown={this.onToggle}>\n                {this.props.label}\n            </span>\n        );\n    }\n}\n\nconst INLINE_STYLES = [\n    { label: \"Bold\", style: \"BOLD\" },\n    { label: \"Italic\", style: \"ITALIC\" },\n    { label: \"Underline\", style: \"UNDERLINE\" },\n    { label: \"Monospace\", style: \"CODE\" },\n];\n\nexport const InlineStyleControls = (props) => {\n    const currentStyle = props.editorState.getCurrentInlineStyle();\n\n    return (\n        <div className=\"RichEditor-controls\">\n            {INLINE_STYLES.map((type) => (\n                <StyleButton\n                    key={type.label}\n                    active={currentStyle.has(type.style)}\n                    label={type.label}\n                    onToggle={props.onToggle}\n                    style={type.style}\n                />\n            ))}\n        </div>\n    );\n};\n\nconst BLOCK_TYPES = [\n    { label: \"H1\", style: \"header-one\" },\n    { label: \"H2\", style: \"header-two\" },\n    { label: \"H3\", style: \"header-three\" },\n    { label: \"H4\", style: \"header-four\" },\n    { label: \"H5\", style: \"header-five\" },\n    { label: \"H6\", style: \"header-six\" },\n    { label: \"Blockquote\", style: \"blockquote\" },\n    { label: \"UL\", style: \"unordered-list-item\" },\n    { label: \"OL\", style: \"ordered-list-item\" },\n    { label: \"Code Block\", style: \"code-block\" },\n];\n\nexport const BlockStyleControls = (props) => {\n    const { editorState } = props;\n    const selection = editorState.getSelection();\n    const blockType = editorState\n        .getCurrentContent()\n        .getBlockForKey(selection.getStartKey())\n        .getType();\n\n    return (\n        <div className=\"RichEditor-controls\">\n            {BLOCK_TYPES.map((type) => (\n                <StyleButton\n                    key={type.label}\n                    active={type.style === blockType}\n                    label={type.label}\n                    onToggle={props.onToggle}\n                    style={type.style}\n                />\n            ))}\n        </div>\n    );\n};\n"},"fluidObjects/draft-js/view/css/MemberList.css":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n.memberList {\n    min-height: 40px;\n}\n\n.memberIcon {\n    display: inline-block;\n    height: 30px;\n    width: 30px;\n    line-height: 30px;\n    text-align: center;\n    border-radius: 15px;\n    color: white;\n    margin: 5px;\n    font-family: Arial, Helvetica, sans-serif;\n}\n"},"fluidObjects/draft-js/view/css/RichEditor.css":{"raw":"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All rights reserved.\n *\n * This file provided by Facebook is for non-commercial testing and evaluation\n * purposes only. Facebook reserves all rights not expressly granted.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n.RichEditor-root {\n    background: #fff;\n    border: 1px solid #ddd;\n    font-family: \"Georgia\", serif;\n    font-size: 14px;\n    padding: 15px;\n}\n\n.RichEditor-editor {\n    cursor: text;\n    font-size: 16px;\n}\n\n.RichEditor-editor .public-DraftEditorPlaceholder-root,\n.RichEditor-editor .public-DraftEditor-content {\n    margin: 0 -15px -15px;\n    padding: 15px;\n}\n\n.RichEditor-editor .public-DraftEditor-content {\n    min-height: 100px;\n}\n\n.RichEditor-hidePlaceholder .public-DraftEditorPlaceholder-root {\n    display: none;\n}\n\n.RichEditor-editor .RichEditor-blockquote {\n    border-left: 5px solid #eee;\n    color: #666;\n    font-family: \"Hoefler Text\", \"Georgia\", serif;\n    font-style: italic;\n    margin: 16px 0;\n    padding: 10px 20px;\n}\n\n.RichEditor-editor .RichEditor-paragraph {\n    margin-bottom: 12px;\n}\n\n.RichEditor-editor .public-DraftStyleDefault-pre {\n    background-color: rgba(0, 0, 0, 0.05);\n    font-family: \"Inconsolata\", \"Menlo\", \"Consolas\", monospace;\n    font-size: 16px;\n    padding: 20px;\n}\n\n.RichEditor-controls {\n    font-family: \"Helvetica\", sans-serif;\n    font-size: 14px;\n    margin-bottom: 5px;\n    user-select: none;\n}\n\n.RichEditor-toolbar {\n    border-bottom: 1px solid #ddd;\n    padding-bottom: 8px;\n}\n\n.RichEditor-toolbar .RichEditor-controls {\n    display: inline-block;\n    border-right: solid 1px #ddd;\n}\n.RichEditor-toolbar .RichEditor-controls:last-child {\n    border-right: none;\n}\n\n.RichEditor-styleButton {\n    color: #999;\n    cursor: pointer;\n    margin: 0 8px;\n    padding: 2px 0;\n    display: inline-block;\n}\n\n.RichEditor-activeButton {\n    color: #5890ff;\n}\n"},"fluidObjects/draft-js/view/index.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport * from \"./FluidDraftJsView\";\nexport * from \"./FluidEditor\";\nexport * from \"./MemberList\";\nexport * from \"./StyleControls\";\n"},"fluidObjects/image-gallery/image-gallery.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    ContainerRuntimeFactoryWithDefaultDataStore,\n    DataObject,\n    DataObjectFactory,\n} from \"@fluidframework/aqueduct\";\nimport { IFluidHTMLView } from \"@fluidframework/view-interfaces\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport ImageGallery from \"react-image-gallery\";\n// eslint-disable-next-line import/no-internal-modules, import/no-unassigned-import\nimport \"react-image-gallery/styles/css/image-gallery.css\";\n// eslint-disable-next-line import/no-unassigned-import\nimport \"./styles.css\";\n\nconst imageGalleryName = \"@fluid-example/image-gallery\";\n\nexport class ImageGalleryComponent extends DataObject implements IFluidHTMLView {\n    public get IFluidHTMLView() { return this; }\n\n    imageList = [\n        {\n            original: \"https://picsum.photos/800/800/?image=400\",\n            thumbnail: \"https://picsum.photos/100/100/?image=400\",\n        },\n        {\n            original: \"https://picsum.photos/800/800/?image=430\",\n            thumbnail: \"https://picsum.photos/100/100/?image=430\",\n        },\n        {\n            original: \"https://picsum.photos/800/800/?image=490\",\n            thumbnail: \"https://picsum.photos/100/100/?image=490\",\n        },\n        {\n            original: \"https://picsum.photos/800/800/?image=580\",\n            thumbnail: \"https://picsum.photos/100/100/?image=580\",\n        },\n        {\n            original: \"https://picsum.photos/800/800/?image=700\",\n            thumbnail: \"https://picsum.photos/100/100/?image=700\",\n        },\n    ];\n\n    defaultProps = {\n        items: [],\n        showNav: true,\n        autoPlay: false,\n        lazyLoad: false,\n    };\n\n    imageGallery: ImageGallery | undefined;\n\n    onSlide = (index: number) => {\n        this.root.set(\"position\", index);\n    };\n\n    reactRender = (div: HTMLDivElement) => {\n        ReactDOM.render(\n            <ImageGallery\n                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n                ref={(gallery: any) => (this.imageGallery = gallery ?? undefined)}\n                items={this.imageList}\n                onSlide={this.onSlide}\n                slideDuration={10}\n            />,\n            div,\n        );\n    };\n\n    protected async initializingFirstTime() {\n        this.root.set(\"position\", 0);\n    }\n\n    public render(div: HTMLDivElement) {\n        div.className = \"app-sandbox\";\n\n        this.reactRender(div);\n        if (this.imageGallery !== undefined) {\n            this.imageGallery.slideToIndex(this.root.get(\"position\"));\n        }\n\n        this.root.on(\"valueChanged\", (_, local) => {\n            const position = this.root.get<number>(\"position\");\n            if (this.imageGallery !== undefined) {\n                // This is a result of a remote slide, don't trigger onSlide for this slide\n                this.reactRender(div);\n                this.imageGallery.slideToIndex(position);\n            }\n        });\n    }\n}\n\nexport const ImageGalleryInstantiationFactory = new DataObjectFactory(\n    imageGalleryName,\n    ImageGalleryComponent,\n    [],\n    {},\n);\n\nexport const fluidExport = new ContainerRuntimeFactoryWithDefaultDataStore(\n    imageGalleryName,\n    new Map([\n        [imageGalleryName, Promise.resolve(ImageGalleryInstantiationFactory)],\n    ]),\n);"},"fluidObjects/image-gallery/styles.css":{"raw":".app-sandbox {\n    margin: 0 auto;\n    max-width: 400px;\n    transition: all 1s ease;\n}"},"fluidObjects/prosemirror/componentView.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Node } from \"prosemirror-model\";\nimport { EditorView, NodeView } from \"prosemirror-view\";\nimport { ILoader } from \"@fluidframework/container-definitions\";\nimport { IFluidObject } from \"@fluidframework/core-interfaces\";\nimport { HTMLViewAdapter } from \"@fluidframework/view-adapters\";\n\nexport class ComponentView implements NodeView {\n    public dom: HTMLElement;\n    public innerView;\n\n    private visual: HTMLViewAdapter | undefined;\n\n    constructor(\n        public node: Node,\n        public outerView: EditorView,\n        public getPos: (() => number) | boolean,\n        public loader: ILoader,\n    ) {\n        // The node's representation in the editor (empty, for now)\n        this.dom = document.createElement(\"fluid\");\n        const src = node.attrs.src;\n        this.load(src);\n    }\n\n    selectNode() {\n        this.dom.classList.add(\"ProseMirror-selectednode\");\n    }\n\n    deselectNode() {\n        this.dom.classList.remove(\"ProseMirror-selectednode\");\n    }\n\n    dispatchInner(tr) {\n    }\n\n    update(node) {\n        return true;\n    }\n\n    destroy() {\n    }\n\n    private load(url: string) {\n        this.attach(url);\n        const containerP = this.loader.resolve({ url });\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        containerP.then((container) => {\n            container.on(\"contextChanged\", (value) => {\n                this.attach(url);\n            });\n        });\n    }\n\n    private attach(url: string) {\n        const loadP = this.loader.request({ url });\n        const componentP = loadP.then(\n            (result) => {\n                if (result.mimeType !== \"fluid/object\") {\n                    throw new Error(\"Can't insert a non-fluid component\");\n                }\n\n                const component = result.value as IFluidObject;\n                if (!HTMLViewAdapter.canAdapt(component)) {\n                    throw new Error(\"Don't know how to render this component\");\n                }\n\n                return component;\n            });\n\n        componentP.then(\n            (component) => {\n                // Remove the previous view\n                if (this.visual) {\n                    this.visual.remove();\n                }\n\n                // Clear any previous content\n                this.dom.innerHTML = \"\";\n\n                this.visual = new HTMLViewAdapter(component);\n                this.visual.render(this.dom);\n            },\n            (error) => {\n                // Fall back to URL if can't load\n                this.dom.innerHTML = `<a href=\"${url}\">${url}</a>`;\n            });\n    }\n}\n"},"fluidObjects/prosemirror/fluidBridge.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport assert from \"assert\";\nimport {\n    createInsertSegmentOp,\n    Marker,\n    ReferenceType,\n    reservedRangeLabelsKey,\n    TextSegment,\n    ISegment,\n    IMergeTreeDeltaOp,\n} from \"@fluidframework/merge-tree\";\nimport {\n    SharedString,\n    // ISequenceDeltaRange,\n    SequenceDeltaEvent,\n    ISequenceDeltaRange,\n} from \"@fluidframework/sequence\";\nimport {\n    Schema, Fragment, Slice,\n    // Slice,\n} from \"prosemirror-model\";\nimport { EditorState, Transaction } from \"prosemirror-state\";\nimport { ReplaceAroundStep } from \"prosemirror-transform\";\n\nexport interface IProseMirrorNode {\n    [key: string]: any;\n    type: string;\n    content?: IProseMirrorNode[];\n    marks?: any[];\n    _open?: boolean;\n}\n\nexport interface IProseMirrorSlice {\n    openStart?: number;\n    openEnd?: number;\n    content: IProseMirrorNode[];\n}\n\nexport const proseMirrorTreeLabel = \"prosemirror\";\n\nexport const nodeTypeKey = \"nodeType\";\n\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport class IProseMirrorTransaction {\n}\n\n// For add/remove mark steps - can they be interspersed with replace and replace around steps???\n// export class AddMarkStep extends Step {\n// export class RemoveMarkStep extends Step {\n// export class ReplaceStep extends Step {\n// export class ReplaceAroundStep extends Step {\n\n// Task is to convert from INSERT/REMOVE/ANNOTATE into addMark/removeMark/replace/replaceAround\n// export class AddMarkStep extends Step {\n// export class RemoveMarkStep extends Step {\n// export class ReplaceStep extends Step {\n//\n// export class ReplaceAroundStep extends Step {\n// :: (number, number, number, number, Slice, number, ?bool)\n// Create a replace-around step with the given range and gap.\n// `insert` should be the point in the slice into which the content\n// of the gap should be moved. `structure` has the same meaning as\n// it has in the [`ReplaceStep`](#transform.ReplaceStep) class.\n\ninterface IThing {\n    type: \"ether\" | \"delete\" | \"insert\" | \"annotate\";\n    event?: ISequenceDeltaRange;\n    length: number;\n    // TODO make use of me!\n    annotations?: any;\n}\n\ninterface IThingGroup {\n    items: IThing[];\n    position: number;\n}\n\nexport class ProseMirrorTransactionBuilder {\n    private readonly transaction: Transaction;\n\n    private readonly things = new Array<IThing>();\n\n    constructor(\n        state: EditorState,\n        private readonly schema: Schema,\n        sharedString: SharedString,\n    ) {\n        this.transaction = state.tr;\n        this.transaction.setMeta(\"fluid-local\", true);\n\n        // Insert an empty node to represent the entire list\n        this.things.push({ type: \"ether\", length: sharedString.getLength() });\n    }\n\n    private splitAt(position: number, offset: number): number {\n        if (position === 0) {\n            return offset;\n        }\n\n        const currentThing = this.things[offset];\n        const newThing: IThing = {\n            type: currentThing.type,\n            event: currentThing.event,\n            length: currentThing.length - position,\n            annotations: currentThing.annotations,\n        };\n        currentThing.length = position;\n        this.things.splice(offset + 1, 0, newThing);\n\n        return offset + 1;\n    }\n\n    private addRange(range: ISequenceDeltaRange) {\n        // Let's assume some things...\n        // ... we will *never* delete an inserted node.\n        // ... deletes will always apply to the ether\n        // ... annotates will apply to non-deleted ether nodes\n\n        let i = 0;\n        let position = range.position;\n        for (i = 0; i < this.things.length; i++) {\n            if (position < this.things[i].length) {\n                // Found our insertion point!\n                break;\n            }\n\n            position -= this.things[i].length;\n        }\n\n        // Position's current value will tell us *where* in this.things[i] to begin inserting\n        switch (range.operation) {\n            case 1: {\n                // Walk the ether looking for the first ether element where position is found. Then split the ether\n                // and add in the removal node.\n                //\n                // For positions we *will* need to include any newly inserted nodes. We can count these as \"new\" ether\n\n                assert(i < this.things.length);\n\n                i = this.splitAt(position, i);\n                let length = range.segment.cachedLength;\n                while (length > 0) {\n                    assert(this.things[i].type === \"ether\");\n\n                    if (this.things[i].length <= length) {\n                        // Ether node is fully encompasing\n                        this.things[i].type = \"delete\";\n                        this.things[i].event = range;\n                        length -= this.things[i].length;\n                        this.things[i].length = 0;\n                        i++;\n                    } else {\n                        // Ether node is partially encompasing. Split it and loop around to then remove it\n                        this.splitAt(length, i);\n                    }\n                }\n\n                break;\n            }\n\n            case 0: {\n                // Walk the ether + new ether (ignoring deletes) looking for the position to insert the element\n                //\n                // Typing the above out it's not all that different from the removal case actually\n                const splicePoint = this.splitAt(position, i);\n                // eslint-disable-next-line max-len\n                this.things.splice(splicePoint, 0, { type: \"insert\", event: range, length: range.segment.cachedLength });\n\n                break;\n            }\n\n            case 2: {\n                // Same walk, except we will split/append the ether with annotations.\n                // Will do this one later. I think I just add an annotations field to the nodes and will go look\n                // for these after the fact\n                // walk the ether looking for the first ether element where position is found. Then split the ether\n                // and add in the removal node.\n                //\n                // For positions we *will* need to include any newly inserted nodes. We can count these as \"new\" ether\n\n                assert(i < this.things.length);\n\n                i = this.splitAt(position, i);\n                let length = range.segment.cachedLength;\n                while (length > 0) {\n                    assert(this.things[i].type === \"ether\");\n\n                    if (this.things[i].length <= length) {\n                        // Ether node is fully encompasing\n                        this.things[i].annotations = range.propertyDeltas;\n                        this.things[i].event = range;\n                        length -= this.things[i].length;\n                        i++;\n                    } else {\n                        // Ether node is partially encompasing. Split it and loop around to then remove it\n                        this.splitAt(length, i);\n                    }\n                }\n\n                break;\n            }\n            default:\n                break;\n        }\n    }\n\n    public addSequencedDelta(delta: SequenceDeltaEvent) {\n        for (const range of delta.ranges) {\n            // The range has a position\n            // ... range.position\n            // And the range has an operation\n            // ... range.operation\n            // And the range has a segment\n            // ... range.segment\n            // And property deltas in the case of an annotate\n            // ... range.propertyDeltas\n            // I need to extract the length given the type\n            // range.segment.cachedLength\n            this.addRange(range);\n            // This.processRange(range);\n        }\n    }\n\n    public build(): Transaction {\n        // console.log(JSON.stringify(this.things.map((t) => ({ type: t.type, length: t.length })), null, 2));\n\n        let currentGroup: IThingGroup;\n        const groups = new Array<IThingGroup>();\n        const annotations = [];\n        let position = 0;\n\n        for (const thing of this.things) {\n            if (thing.type === \"ether\") {\n                if (thing.annotations) {\n                    annotations.push({\n                        from: position,\n                        to: position + thing.length,\n                        segment: thing.event.segment,\n                        propertyDeltas: thing.annotations,\n                    });\n                }\n\n                currentGroup = undefined;\n                position += thing.length;\n            } else {\n                if (!currentGroup) {\n                    currentGroup = { items: [], position };\n                    groups.push(currentGroup);\n                }\n\n                currentGroup.items.push(thing);\n            }\n        }\n\n        // For now we *just* support replace range\n        console.log(`Total groups! ${groups.length}`);\n\n        if (groups.length === 1) {\n            const group = groups[0];\n\n            let removalSize = 0;\n            const insertSegments = [];\n\n            group.items.forEach((value) => {\n                if (value.type === \"delete\") {\n                    removalSize += value.event.segment.cachedLength;\n                } else {\n                    insertSegments.push(value.event.segment);\n                }\n            });\n\n            const fragment = generateFragment(insertSegments);\n            const slice = new Slice(\n                Fragment.fromJSON(this.schema, fragment),\n                this.getOpenStart(fragment),\n                this.getOpenEnd(fragment));\n\n            this.transaction.replaceRange(\n                group.position,\n                group.position + removalSize,\n                slice);\n        } else if (groups.length > 1) {\n            const removalSizes = [];\n            const insertSizes = [];\n            const insertSegments = [];\n\n            for (const group of groups) {\n                let removalSize = 0;\n                let groupSize = 0;\n\n                group.items.forEach((value) => {\n                    if (value.type === \"delete\") {\n                        removalSize += value.event.segment.cachedLength;\n                    } else {\n                        insertSegments.push(value.event.segment);\n                        groupSize += value.event.segment.cachedLength;\n                    }\n                });\n\n                removalSizes.push(removalSize);\n                insertSizes.push(groupSize);\n            }\n\n            const fragment = generateFragment(insertSegments);\n            const slice = new Slice(\n                Fragment.fromJSON(this.schema, fragment),\n                this.getOpenStart(fragment),\n                this.getOpenEnd(fragment));\n\n            const gapSize = groups[1].position - groups[0].position;\n\n            this.transaction.step(new ReplaceAroundStep(\n                groups[0].position,\n                groups[0].position + removalSizes[0] + gapSize + removalSizes[1],\n                groups[0].position + removalSizes[0],\n                groups[0].position + removalSizes[0] + gapSize,\n                slice,\n                insertSizes[0]));\n        }\n\n        // Apply annotations\n        for (const annotation of annotations) {\n            const segment = annotation.segment;\n            // An annotation should just be an immediate flush - I think\n            for (const prop of Object.keys(annotation.propertyDeltas)) {\n                const value = segment.properties[prop];\n\n                if (value) {\n                    this.transaction.addMark(\n                        annotation.from,\n                        annotation.to,\n                        this.schema.marks[prop].create(value));\n                } else {\n                    this.transaction.removeMark(\n                        annotation.from,\n                        annotation.to,\n                        this.schema.marks[prop]);\n                }\n            }\n        }\n\n        return this.transaction;\n    }\n\n    private getOpenStart(node: IProseMirrorNode[]): number {\n        if (!node || node.length === 0) {\n            return 0;\n        }\n\n        const start = node[0];\n        return !start._open || !start.content ? 0 : 1 + this.getOpenStart(start.content);\n    }\n\n    private getOpenEnd(node: IProseMirrorNode[]): number {\n        if (!node || node.length === 0) {\n            return 0;\n        }\n\n        const end = node[node.length - 1];\n        return !end._open || !end.content ? 0 : 1 + this.getOpenEnd(end.content);\n    }\n}\n\nexport function sliceToGroupOps(\n    from: number,\n    slice: IProseMirrorSlice,\n    schema: Schema,\n    insert?: number,\n    gapDistance?: number,\n): IMergeTreeDeltaOp[] {\n    const ops = new Array<IMergeTreeDeltaOp>();\n\n    const sliceOpenStart = slice.openStart || 0;\n    const sliceOpenEnd = slice.openEnd || 0;\n    let offset = from + adjustOffset(from, 0, 0, insert, gapDistance);\n\n    slice.content.forEach((value, index) => {\n        const openStart = index === 0 ? sliceOpenStart - 1 : -1;\n        const openEnd = index === slice.content.length - 1 ? sliceOpenEnd - 1 : -1;\n\n        offset += sliceToGroupOpsInternal(value, schema, openStart, openEnd, offset, ops, insert, gapDistance);\n    });\n\n    return ops;\n}\n\n// Likely a cleaner way to detect the gap than checking every offset adjust - but brute forcing for now\nfunction adjustOffset(from, offset, value, insert, gapDistance) {\n    const newFrom = from + offset + value;\n    return newFrom === insert ? offset + value + gapDistance : offset + value;\n}\n\nfunction sliceToGroupOpsInternal(\n    value: IProseMirrorNode,\n    schema: Schema,\n    openStart: number,\n    openEnd: number,\n    from: number,\n    ops: IMergeTreeDeltaOp[],\n    insert?: number,\n    gapDistance?: number,\n) {\n    let offset = 0;\n\n    let props: any;\n    if (value.marks) {\n        props = {};\n        for (const mark of value.marks) {\n            props[mark.type] = mark.attrs || true;\n        }\n    }\n\n    const node = schema.nodes[value.type];\n    if (node.isInline) {\n        if (value.type === \"text\") {\n            const segment = new TextSegment(value.text);\n            if (props) {\n                segment.addProperties(props);\n            }\n            ops.push(createInsertSegmentOp(from + offset, segment));\n\n            offset = adjustOffset(from, offset, value.text.length, insert, gapDistance);\n        } else {\n            const nodeProps = {\n                ...props,\n                ...{\n                    type: value.type,\n                    attrs: value.attrs,\n                },\n            };\n\n            const marker = new Marker(ReferenceType.Simple);\n            marker.addProperties(nodeProps);\n            ops.push(createInsertSegmentOp(from + offset, marker));\n\n            offset = adjustOffset(from, offset, 1, insert, gapDistance);\n        }\n    } else {\n        // Negative open start indicates we have past the depth from which the opening began\n        if (openStart < 0) {\n            const beginProps = {\n                ...props,\n                ...{\n                    [reservedRangeLabelsKey]: [proseMirrorTreeLabel],\n                    [nodeTypeKey]: value.type,\n                },\n            };\n\n            const marker = new Marker(ReferenceType.NestBegin);\n            marker.addProperties(beginProps);\n            ops.push(createInsertSegmentOp(from + offset, marker));\n\n            offset = adjustOffset(from, offset, 1, insert, gapDistance);\n        }\n\n        if (value.content) {\n            value.content.forEach((content, index) => {\n                offset += sliceToGroupOpsInternal(\n                    content,\n                    schema,\n                    index === 0 ? openStart - 1 : -1,\n                    index === value.content.length - 1 ? openEnd - 1 : -1,\n                    from + offset,\n                    ops,\n                    insert,\n                    gapDistance);\n            });\n        }\n\n        if (openEnd < 0) {\n            const endProps = {\n                ...props,\n                ...{\n                    [reservedRangeLabelsKey]: [proseMirrorTreeLabel],\n                    [nodeTypeKey]: value.type,\n                },\n            };\n\n            const marker = new Marker(ReferenceType.NestEnd);\n            marker.addProperties(endProps);\n            ops.push(createInsertSegmentOp(from + offset, marker));\n\n            offset = adjustOffset(from, offset, 1, insert, gapDistance);\n        }\n    }\n\n    return offset;\n}\n\nfunction generateFragment(segments: ISegment[]) {\n    const nodeStack = new Array<IProseMirrorNode>();\n    nodeStack.push({ type: \"doc\", content: [] });\n\n    let openTop: IProseMirrorNode;\n\n    // TODO should I pre-seed the data structure based on the nodes to the left of the open?\n\n    for (const segment of segments) {\n        const top = nodeStack[nodeStack.length - 1];\n\n        if (TextSegment.is(segment)) {\n            const nodeJson: IProseMirrorNode = {\n                type: \"text\",\n                text: segment.text,\n            };\n\n            if (segment.properties) {\n                nodeJson.marks = [];\n                for (const propertyKey of Object.keys(segment.properties)) {\n                    nodeJson.marks.push({\n                        type: propertyKey,\n                        value: segment.properties[propertyKey],\n                    });\n                }\n            }\n\n            top.content.push(nodeJson);\n        } else if (Marker.is(segment)) {\n            const nodeType = segment.properties[nodeTypeKey];\n            switch (segment.refType) {\n                case ReferenceType.NestBegin:\n                    // Special case the open top\n                    if (openTop) {\n                        top.content.push(openTop);\n                        openTop = undefined;\n                    }\n                    // Create the new node, add it to the top's content, and push it on the stack\n                    const newNode = { type: nodeType, content: [], _open: true };\n                    top.content.push(newNode);\n                    nodeStack.push(newNode);\n                    break;\n\n                case ReferenceType.NestEnd:\n                    if (top.type === nodeType) {\n                        top._open = false;\n                        // Matching open\n                        nodeStack.pop();\n                    } else {\n                        // Unmatched open\n                        const newNode2 = { type: nodeType, content: [], _open: true };\n                        if (openTop) {\n                            newNode2.content.push(openTop);\n                        }\n\n                        openTop = newNode2;\n                    }\n\n                    break;\n\n                case ReferenceType.Simple:\n                    // TODO consolidate the text segment and simple references\n                    const nodeJson: IProseMirrorNode = {\n                        type: segment.properties.type,\n                        attrs: segment.properties.attrs,\n                    };\n\n                    if (segment.properties) {\n                        nodeJson.marks = [];\n                        for (const propertyKey of Object.keys(segment.properties)) {\n                            if (propertyKey !== \"type\" && propertyKey !== \"attrs\") {\n                                nodeJson.marks.push({\n                                    type: propertyKey,\n                                    value: segment.properties[propertyKey],\n                                });\n                            }\n                        }\n                    }\n\n                    top.content.push(nodeJson);\n                    break;\n\n                default:\n                    // Throw for now when encountering something unknown\n                    throw new Error(\"Unknown marker\");\n            }\n        }\n    }\n\n    const doc = nodeStack[0];\n    const content = doc.content;\n\n    // We do a fix up down the left edge for all the open nodes since we need to change the ordering. Likely\n    // better way to do this but holding off until better understand slice use\n    // if (content[0] && content[0]._open) {\n    //     let prev;\n    //     let current = content[0];\n    //     while (current) {\n    //         const next = current.content ? current.content[0] : undefined;\n    //         prev = current;\n    //         current = next;\n    //     }\n    //     content[0] = prev;\n    // }\n\n    return content;\n}\n\n// TODO a replace should be an entire group\n// iterate over all elements and create a new fragment\n\n// {\n//     \"stepType\": \"replace\",\n//     \"from\": 14,\n//     \"to\": 14,\n//     \"slice\": {\n//         \"content\": [\n//         {\n//             \"type\": \"paragraph\"\n//         },\n//         {\n//             \"type\": \"paragraph\"\n//         }\n//         ],\n//         \"openStart\": 1,\n//         \"openEnd\": 1\n//     },\n//     \"structure\": true\n// }\n\n// When `structure` is true, the step will fail if the content between\n// from and to is not just a sequence of closing and then opening\n// tokens (this is to guard against rebased replace steps\n// overwriting something they weren't supposed to).\n\n// collab cursor\n// https://discuss.prosemirror.net/t/collaborative-editor-show-other-users-cursor-position/1862\n"},"fluidObjects/prosemirror/fluidCollabManager.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport assert from \"assert\";\nimport { EventEmitter } from \"events\";\nimport OrderedMap from \"orderedmap\";\nimport { ILoader } from \"@fluidframework/container-definitions\";\nimport {\n    createGroupOp,\n    createRemoveRangeOp,\n    Marker,\n    ReferenceType,\n    TextSegment,\n    IMergeTreeDeltaOp,\n} from \"@fluidframework/merge-tree\";\nimport { SharedString } from \"@fluidframework/sequence\";\nimport { buildMenuItems, exampleSetup } from \"prosemirror-example-setup\";\nimport { MenuItem } from \"prosemirror-menu\";\nimport { DOMSerializer, Fragment, NodeSpec, Schema, Slice } from \"prosemirror-model\";\nimport { addListNodes } from \"prosemirror-schema-list\";\nimport { EditorState, NodeSelection, Plugin, Transaction } from \"prosemirror-state\";\nimport { insertPoint } from \"prosemirror-transform\";\nimport { EditorView } from \"prosemirror-view\";\nimport { ComponentView } from \"./componentView\";\nimport { IProseMirrorNode, nodeTypeKey, ProseMirrorTransactionBuilder, sliceToGroupOps } from \"./fluidBridge\";\nimport { schema } from \"./fluidSchema\";\nimport { FootnoteView } from \"./footnoteView\";\nimport { openPrompt, TextField } from \"./prompt\";\nimport { create as createSelection } from \"./selection\";\n\ndeclare module \"@fluidframework/core-interfaces\" {\n    // eslint-disable-next-line @typescript-eslint/no-empty-interface\n    export interface IFluidObject extends Readonly<Partial<IProvideRichTextEditor>> { }\n}\n\nexport const IRichTextEditor: keyof IProvideRichTextEditor = \"IRichTextEditor\";\n\nexport interface IProvideRichTextEditor {\n    readonly IRichTextEditor: IRichTextEditor;\n}\n\nexport interface IRichTextEditor extends IProvideRichTextEditor {\n    getValue(): string;\n\n    initializeValue(value: string): void;\n}\n\nexport class FluidCollabManager extends EventEmitter implements IRichTextEditor {\n    public get IRichTextEditor() { return this; }\n\n    public readonly plugin: Plugin;\n    private readonly schema: Schema;\n    private state: EditorState;\n    private editorView: EditorView;\n\n    constructor(private readonly text: SharedString, private readonly loader: ILoader) {\n        super();\n\n        this.plugin = new Plugin({\n            state: {\n                init: () => null,\n                apply: (tr) => {\n                    this.applyTransaction(tr);\n                    return null;\n                },\n            },\n        });\n\n        const fluidSchema = new Schema({\n            nodes: addListNodes(schema.spec.nodes as OrderedMap<NodeSpec>, \"paragraph block*\", \"block\"),\n            marks: schema.spec.marks,\n        });\n        this.schema = fluidSchema;\n\n        // Initialize the base ProseMirror JSON data structure\n        const nodeStack = new Array<IProseMirrorNode>();\n        nodeStack.push({ type: \"doc\", content: [] });\n\n        this.text.walkSegments((segment) => {\n            const top = nodeStack[nodeStack.length - 1];\n\n            if (TextSegment.is(segment)) {\n                const nodeJson: IProseMirrorNode = {\n                    type: \"text\",\n                    text: segment.text,\n                };\n\n                if (segment.properties) {\n                    nodeJson.marks = [];\n                    for (const propertyKey of Object.keys(segment.properties)) {\n                        nodeJson.marks.push({\n                            type: propertyKey,\n                            value: segment.properties[propertyKey],\n                        });\n                    }\n                }\n\n                top.content.push(nodeJson);\n            } else if (Marker.is(segment)) {\n                // TODO are marks applied to the structural nodes as well? Or just inner text?\n\n                const nodeType = segment.properties[nodeTypeKey];\n                switch (segment.refType) {\n                    case ReferenceType.NestBegin:\n                        // Create the new node, add it to the top's content, and push it on the stack\n                        const newNode = { type: nodeType, content: [] };\n                        top.content.push(newNode);\n                        nodeStack.push(newNode);\n                        break;\n\n                    case ReferenceType.NestEnd:\n                        const popped = nodeStack.pop();\n                        assert(popped.type === nodeType);\n                        break;\n\n                    case ReferenceType.Simple:\n                        // TODO consolidate the text segment and simple references\n                        const nodeJson: IProseMirrorNode = {\n                            type: segment.properties.type,\n                            attrs: segment.properties.attrs,\n                        };\n\n                        if (segment.properties) {\n                            nodeJson.marks = [];\n                            for (const propertyKey of Object.keys(segment.properties)) {\n                                if (propertyKey !== \"type\" && propertyKey !== \"attrs\") {\n                                    nodeJson.marks.push({\n                                        type: propertyKey,\n                                        value: segment.properties[propertyKey],\n                                    });\n                                }\n                            }\n                        }\n\n                        top.content.push(nodeJson);\n                        break;\n\n                    default:\n                        // Throw for now when encountering something unknown\n                        throw new Error(\"Unknown marker\");\n                }\n            }\n\n            return true;\n        });\n\n        const menu = buildMenuItems(this.schema);\n        menu.insertMenu.content.push(new MenuItem({\n            title: \"Insert Component\",\n            label: \"Component\",\n            enable: (state) => true,\n            run: (state, _, view) => {\n                const { from, to } = state.selection;\n                let nodeAttrs = null;\n                if (state.selection instanceof NodeSelection && state.selection.node.type === fluidSchema.nodes.fluid) {\n                    nodeAttrs = state.selection.node.attrs;\n                }\n                openPrompt({\n                    title: \"Insert component\",\n                    fields: {\n                        src: new TextField({ label: \"Url\", required: true, value: nodeAttrs && nodeAttrs.src }),\n                        title: new TextField({ label: \"Title\", value: nodeAttrs && nodeAttrs.title }),\n                        alt: new TextField({\n                            label: \"Description\",\n                            value: nodeAttrs ? nodeAttrs.alt : state.doc.textBetween(from, to, \" \"),\n                        }),\n                    },\n                    callback(attrs) {\n                        view.dispatch(view.state.tr.replaceSelectionWith(fluidSchema.nodes.fluid.createAndFill(attrs)));\n                        view.focus();\n                    },\n                });\n            },\n        }));\n\n        menu.insertMenu.content.push(new MenuItem({\n            title: \"Insert footnote\",\n            label: \"Footnote\",\n            select: (state) => insertPoint(state.doc, state.selection.from, fluidSchema.nodes.footnote) != null,\n            run(state, dispatch) {\n                const { empty, $from, $to } = state.selection;\n                let content = Fragment.empty;\n                if (!empty && $from.sameParent($to) && $from.parent.inlineContent) {\n                    content = $from.parent.content.cut($from.parentOffset, $to.parentOffset);\n                }\n                dispatch(state.tr.replaceSelectionWith(fluidSchema.nodes.footnote.create(null, content)));\n            },\n        }));\n\n        const doc = nodeStack.pop();\n        // console.log(JSON.stringify(doc, null, 2));\n\n        const fluidDoc = this.schema.nodeFromJSON(doc);\n        this.state = EditorState.create({\n            doc: fluidDoc,\n            plugins:\n                exampleSetup({\n                    schema: this.schema,\n                    menuContent: menu.fullMenu,\n                })\n                    .concat(this.plugin)\n                    .concat(createSelection()),\n        });\n\n        let sliceBuilder: ProseMirrorTransactionBuilder;\n\n        this.text.on(\n            \"pre-op\",\n            (op, local) => {\n                if (local) {\n                    return;\n                }\n\n                const startState = this.getCurrentState();\n                sliceBuilder = new ProseMirrorTransactionBuilder(\n                    startState,\n                    this.schema,\n                    this.text);\n            });\n\n        this.text.on(\n            \"sequenceDelta\",\n            (ev) => {\n                if (ev.isLocal) {\n                    return;\n                }\n\n                sliceBuilder.addSequencedDelta(ev);\n            });\n\n        this.text.on(\n            \"op\",\n            (op, local) => {\n                this.emit(\"valueChanged\");\n\n                if (local) {\n                    return;\n                }\n\n                const tr = sliceBuilder.build();\n                this.apply(tr);\n            });\n    }\n\n    public getValue(): string {\n        const currentState = this.getCurrentState();\n\n        const fragment = DOMSerializer\n            .fromSchema(this.schema)\n            .serializeFragment(currentState.doc.content);\n        const wrapper = document.createElement(\"div\");\n        wrapper.appendChild(fragment);\n        return wrapper.innerHTML;\n    }\n\n    public initializeValue(value: string): void {\n        const state = this.getCurrentState();\n        const tr = state.tr;\n        const node = this.schema.nodeFromJSON(\n            {\n                type: \"paragraph\",\n                content: [\n                    {\n                        type: \"text\",\n                        text: value,\n                    },\n                ],\n            });\n\n        tr.replaceRange(0, state.doc.content.size, new Slice(node.content, 0, 0));\n\n        this.apply(tr);\n    }\n\n    public setupEditor(textArea: HTMLDivElement) {\n        /* eslint-disable @typescript-eslint/no-require-imports,\n        import/no-internal-modules, import/no-unassigned-import */\n        require(\"prosemirror-view/style/prosemirror.css\");\n        require(\"prosemirror-menu/style/menu.css\");\n        require(\"prosemirror-example-setup/style/style.css\");\n        require(\"./style.css\");\n        /* eslint-enable @typescript-eslint/no-require-imports,\n        import/no-internal-modules, import/no-unassigned-import */\n\n        const editorView = new EditorView(\n            textArea,\n            {\n                state: this.state,\n                nodeViews: {\n                    fluid: (node, view, getPos) => new ComponentView(node, view, getPos, this.loader),\n                    footnote: (node, view, getPos) => new FootnoteView(node, view, getPos, this.loader),\n                },\n            });\n\n        this.editorView = editorView;\n\n        // eslint-disable-next-line dot-notation\n        window[\"easyView\"] = editorView;\n\n        return editorView;\n    }\n\n    private getCurrentState() {\n        return this.editorView ? this.editorView.state : this.state;\n    }\n\n    private apply(tr: Transaction) {\n        if (this.editorView) {\n            this.editorView.dispatch(tr);\n        } else {\n            this.state = this.state.apply(tr);\n        }\n    }\n\n    private applyTransaction(tr: Transaction) {\n        if (tr.getMeta(\"fluid-local\")) {\n            return;\n        }\n\n        for (const step of tr.steps) {\n            // This is a good place for me to tweak changes and ignore local stuff...\n            // console.log(JSON.stringify(step, null, 2));\n\n            const stepAsJson = step.toJSON();\n            switch (stepAsJson.stepType) {\n                case \"replace\": {\n                    const from = stepAsJson.from;\n                    const to = stepAsJson.to;\n\n                    let operations = new Array<IMergeTreeDeltaOp>();\n\n                    if (from !== to) {\n                        const removeOp = createRemoveRangeOp(from, to);\n                        operations.push(removeOp);\n                    }\n\n                    if (stepAsJson.slice) {\n                        const sliceOperations = sliceToGroupOps(\n                            from,\n                            stepAsJson.slice,\n                            this.schema);\n                        operations = operations.concat(sliceOperations);\n                    }\n\n                    const groupOp = createGroupOp(...operations);\n                    this.text.groupOperation(groupOp);\n\n                    break;\n                }\n\n                case \"replaceAround\": {\n                    let operations = new Array<IMergeTreeDeltaOp>();\n\n                    const from = stepAsJson.from;\n                    const to = stepAsJson.to;\n                    const gapFrom = stepAsJson.gapFrom;\n                    const gapTo = stepAsJson.gapTo;\n                    const insert = stepAsJson.insert;\n\n                    // Export class ReplaceAroundStep extends Step {\n                    // :: (number, number, number, number, Slice, number, ?bool)\n                    // Create a replace-around step with the given range and gap.\n                    // `insert` should be the point in the slice into which the content\n                    // of the gap should be moved. `structure` has the same meaning as\n                    // it has in the [`ReplaceStep`](#transform.ReplaceStep) class.\n                    // {\n                    //     \"stepType\": \"replaceAround\",\n                    //     \"from\": 0,\n                    //     \"to\": 15,\n                    //     \"gapFrom\": 0,\n                    //     \"gapTo\": 15,\n                    //     \"insert\": 2,\n                    //     \"slice\": {\n                    //         \"content\": [\n                    //         {\n                    //             \"type\": \"bullet_list\",\n                    //             \"content\": [\n                    //             {\n                    //                 \"type\": \"list_item\"\n                    //             }\n                    //             ]\n                    //         }\n                    //         ]\n                    //     },\n                    //     \"structure\": true\n                    //     }\n\n                    if (gapTo !== to) {\n                        const removeOp = createRemoveRangeOp(gapTo, to);\n                        operations.push(removeOp);\n                    }\n\n                    if (gapFrom !== from) {\n                        const removeOp = createRemoveRangeOp(from, gapFrom);\n                        operations.push(removeOp);\n                    }\n\n                    if (stepAsJson.slice) {\n                        const sliceOperations = sliceToGroupOps(\n                            from,\n                            stepAsJson.slice,\n                            this.schema,\n                            insert ? from + insert : insert,\n                            gapTo - gapFrom);\n                        operations = operations.concat(sliceOperations);\n                    }\n\n                    const groupOp = createGroupOp(...operations);\n                    this.text.groupOperation(groupOp);\n\n                    break;\n                }\n\n                case \"addMark\": {\n                    const attrs = stepAsJson.mark.attrs || true;\n\n                    this.text.annotateRange(\n                        stepAsJson.from,\n                        stepAsJson.to,\n                        { [stepAsJson.mark.type]: attrs });\n\n                    break;\n                }\n\n                case \"removeMark\": {\n                    // Is there a way to actually clear an annotation?\n                    this.text.annotateRange(\n                        stepAsJson.from,\n                        stepAsJson.to,\n                        { [stepAsJson.mark.type]: false });\n\n                    break;\n                }\n\n                default:\n                    break;\n            }\n        }\n    }\n}\n"},"fluidObjects/prosemirror/fluidSchema.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n// Fork of https://github.com/ProseMirror/prosemirror-schema-basic/blob/master/src/schema-basic.js\n\nimport { Schema } from \"prosemirror-model\";\n\nconst pDOM = [\"p\", 0];\nconst blockquoteDOM = [\"blockquote\", 0];\nconst hrDOM = [\"hr\"];\nconst preDOM = [\"pre\", [\"code\", 0]];\nconst brDOM = [\"br\"];\n\n// :: Object\n// [Specs](#model.NodeSpec) for the nodes defined in this schema.\nexport const nodes = {\n    // :: NodeSpec The top level document node.\n    doc: {\n        // Making one block to start for simplicity\n        content: \"block+\",\n    },\n\n    // :: NodeSpec A plain paragraph textblock. Represented in the DOM\n    // as a `<p>` element.\n    paragraph: {\n        content: \"inline*\",\n        group: \"block\",\n        parseDOM: [{ tag: \"p\" }],\n        toDOM: () => pDOM,\n    },\n\n    // :: NodeSpec A blockquote (`<blockquote>`) wrapping one or more blocks.\n    blockquote: {\n        content: \"block+\",\n        group: \"block\",\n        defining: true,\n        parseDOM: [{ tag: \"blockquote\" }],\n        toDOM: () => blockquoteDOM,\n    },\n\n    // :: NodeSpec A horizontal rule (`<hr>`).\n    horizontal_rule: {\n        group: \"block\",\n        parseDOM: [{ tag: \"hr\" }],\n        toDOM: () => hrDOM,\n    },\n\n    // :: NodeSpec A heading textblock, with a `level` attribute that\n    // should hold the number 1 to 6. Parsed and serialized as `<h1>` to\n    // `<h6>` elements.\n    heading: {\n        attrs: { level: { default: 1 } },\n        content: \"inline*\",\n        group: \"block\",\n        defining: true,\n        parseDOM: [\n            { tag: \"h1\", attrs: { level: 1 } },\n            { tag: \"h2\", attrs: { level: 2 } },\n            { tag: \"h3\", attrs: { level: 3 } },\n            { tag: \"h4\", attrs: { level: 4 } },\n            { tag: \"h5\", attrs: { level: 5 } },\n            { tag: \"h6\", attrs: { level: 6 } },\n        ],\n        toDOM: (node) => [`h${node.attrs.level}`, 0],\n    },\n\n    // :: NodeSpec A code listing. Disallows marks or non-text inline\n    // nodes by default. Represented as a `<pre>` element with a\n    // `<code>` element inside of it.\n    code_block: {\n        content: \"text*\",\n        marks: \"\",\n        group: \"block\",\n        code: true,\n        defining: true,\n        parseDOM: [{ tag: \"pre\", preserveWhitespace: \"full\" }],\n        toDOM: () => preDOM,\n    },\n\n    // :: NodeSpec The text node.\n    text: {\n        group: \"inline\",\n    },\n\n    // :: NodeSpec An inline image (`<img>`) node. Supports `src`,\n    // `alt`, and `href` attributes. The latter two default to the empty\n    // string.\n    fluid: {\n        group: \"inline\",\n        content: \"inline*\",\n        inline: true,\n        draggable: true,\n        // This makes the view treat the node as a leaf, even though it\n        // technically has content\n        atom: true,\n        toDOM(node) {\n            const { src, alt, title } = node.attrs;\n            return [\"fluid\", { src, alt, title }];\n        },\n        parseDOM: [{\n            tag: \"fluid\", getAttrs: (dom) => ({\n                alt: dom.getAttribute(\"alt\"),\n                src: dom.getAttribute(\"src\"),\n                title: dom.getAttribute(\"title\"),\n            }),\n        }],\n        attrs: {\n            src: { default: \"\" },\n            alt: { default: null },\n            title: { default: null },\n        },\n    },\n\n    footnote: {\n        group: \"inline\",\n        content: \"inline*\",\n        inline: true,\n        draggable: true,\n        // This makes the view treat the node as a leaf, even though it\n        // technically has content\n        atom: true,\n        toDOM: () => [\"footnote\", 0],\n        parseDOM: [{ tag: \"footnote\" }],\n    },\n\n    // :: NodeSpec An inline image (`<img>`) node. Supports `src`,\n    // `alt`, and `href` attributes. The latter two default to the empty\n    // string.\n    image: {\n        inline: true,\n        attrs: {\n            src: {},\n            alt: { default: null },\n            title: { default: null },\n        },\n        group: \"inline\",\n        draggable: true,\n        parseDOM: [{\n            tag: \"img[src]\", getAttrs: (dom) => ({\n                src: dom.getAttribute(\"src\"),\n                title: dom.getAttribute(\"title\"),\n                alt: dom.getAttribute(\"alt\"),\n            }),\n        }],\n        toDOM(node) { const { src, alt, title } = node.attrs; return [\"img\", { src, alt, title }]; },\n    },\n\n    // :: NodeSpec A hard line break, represented in the DOM as `<br>`.\n    hard_break: {\n        inline: true,\n        group: \"inline\",\n        selectable: false,\n        parseDOM: [{ tag: \"br\" }],\n        toDOM: () => brDOM,\n    },\n};\n\nconst emDOM = [\"em\", 0];\nconst strongDOM = [\"strong\", 0];\nconst codeDOM = [\"code\", 0];\n\n// :: Object [Specs](#model.MarkSpec) for the marks in the schema.\nexport const marks = {\n    // :: MarkSpec A link. Has `href` and `title` attributes. `title`\n    // defaults to the empty string. Rendered and parsed as an `<a>`\n    // element.\n    link: {\n        attrs: {\n            href: {},\n            title: { default: null },\n        },\n        inclusive: false,\n        parseDOM: [{\n            tag: \"a[href]\", getAttrs: (dom) => ({ href: dom.getAttribute(\"href\"), title: dom.getAttribute(\"title\") }),\n        }],\n        toDOM(node) { const { href, title } = node.attrs; return [\"a\", { href, title }, 0]; },\n    },\n\n    // :: MarkSpec An emphasis mark. Rendered as an `<em>` element.\n    // Has parse rules that also match `<i>` and `font-style: italic`.\n    em: {\n        parseDOM: [{ tag: \"i\" }, { tag: \"em\" }, { style: \"font-style=italic\" }],\n        toDOM: () => emDOM,\n    },\n\n    // :: MarkSpec A strong mark. Rendered as `<strong>`, parse rules\n    // also match `<b>` and `font-weight: bold`.\n    strong: {\n        parseDOM: [\n            { tag: \"strong\" },\n            // This works around a Google Docs misbehavior where\n            // pasted content will be inexplicably wrapped in `<b>`\n            // tags with a font-weight normal.\n            { tag: \"b\", getAttrs: (node) => node.style.fontWeight !== \"normal\" && null },\n            { style: \"font-weight\", getAttrs: (value) => /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null },\n        ],\n        toDOM: () => strongDOM,\n    },\n\n    // :: MarkSpec Code font mark. Represented as a `<code>` element.\n    code: {\n        parseDOM: [{ tag: \"code\" }],\n        toDOM: () => codeDOM,\n    },\n};\n\n// :: Schema\n// This schema rougly corresponds to the document schema used by\n// [CommonMark](http://commonmark.org/), minus the list elements,\n// which are defined in the [`prosemirror-schema-list`](#schema-list)\n// module.\n//\n// To reuse elements from this schema, extend or read from its\n// `spec.nodes` and `spec.marks` [properties](#model.Schema.spec).\nexport const schema = new Schema({ nodes: nodes as any, marks: marks as any });\n"},"fluidObjects/prosemirror/footnoteView.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { StepMap } from \"prosemirror-transform\";\nimport { keymap } from \"prosemirror-keymap\";\nimport { undo, redo } from \"prosemirror-history\";\nimport { EditorView } from \"prosemirror-view\";\nimport { EditorState } from \"prosemirror-state\";\nimport { ILoader } from \"@fluidframework/container-definitions\";\nimport { ComponentView } from \"./componentView\";\n\nexport class FootnoteView {\n    public node;\n    public outerView;\n    public getPos;\n    public dom;\n    public innerView;\n\n    constructor(node, view, getPos, private readonly loader: ILoader) {\n        // We'll need these later\n        this.node = node;\n        this.outerView = view;\n        this.getPos = getPos;\n\n        // The node's representation in the editor (empty, for now)\n        this.dom = document.createElement(\"footnote\");\n        // These are used when the footnote is selected\n        this.innerView = null;\n    }\n\n    selectNode() {\n        this.dom.classList.add(\"ProseMirror-selectednode\");\n        if (!this.innerView) { this.open(); }\n    }\n\n    deselectNode() {\n        this.dom.classList.remove(\"ProseMirror-selectednode\");\n        if (this.innerView) { this.close(); }\n    }\n\n    open() {\n        // Append a tooltip to the outer node\n        const tooltip = this.dom.appendChild(document.createElement(\"div\"));\n        tooltip.className = \"footnote-tooltip\";\n        // And put a sub-ProseMirror into that\n        this.innerView = new EditorView(tooltip, {\n            // You can use any node as an editor document\n            state: EditorState.create({\n                doc: this.node,\n                plugins: [keymap({\n                    \"Mod-z\": () => undo(this.outerView.state, this.outerView.dispatch),\n                    \"Mod-y\": () => redo(this.outerView.state, this.outerView.dispatch),\n                })],\n            }),\n            nodeViews: {\n                fluid: (node, view, getPos) => new ComponentView(node, view, getPos, this.loader),\n            },\n            // This is the magic part\n            dispatchTransaction: this.dispatchInner.bind(this),\n            handleDOMEvents: {\n                mousedown: () => {\n                    // Kludge to prevent issues due to the fact that the whole\n                    // footnote is node-selected (and thus DOM-selected) when\n                    // the parent editor is focused.\n                    if (this.outerView.hasFocus()) { this.innerView.focus(); }\n                    return true;\n                },\n            },\n        });\n    }\n\n    close() {\n        this.innerView.destroy();\n        this.innerView = null;\n        this.dom.textContent = \"\";\n    }\n\n    dispatchInner(tr) {\n        const { state, transactions } = this.innerView.state.applyTransaction(tr);\n        this.innerView.updateState(state);\n\n        if (!tr.getMeta(\"fromOutside\")) {\n            const outerTr = this.outerView.state.tr; const offsetMap = StepMap.offset(this.getPos() + 1);\n\n            for (const transaction of transactions) {\n                for (const step of transaction.steps) {\n                    outerTr.step(step).map(offsetMap);\n                }\n            }\n\n            if (outerTr.docChanged) {\n                this.outerView.dispatch(outerTr);\n            }\n        }\n    }\n\n    update(node) {\n        if (!node.sameMarkup(this.node)) { return false; }\n        this.node = node;\n        if (this.innerView) {\n            const state = this.innerView.state;\n            const start = node.content.findDiffStart(state.doc.content);\n            if (start != null) {\n                let { a: endA, b: endB } = node.content.findDiffEnd(state.doc.content);\n                const overlap = start - Math.min(endA, endB);\n                if (overlap > 0) { endA += overlap; endB += overlap; }\n                this.innerView.dispatch(\n                    state.tr\n                        .replace(start, endB, node.slice(start, endA))\n                        .setMeta(\"fromOutside\", true));\n            }\n        }\n        return true;\n    }\n\n    destroy() {\n        if (this.innerView) { this.close(); }\n    }\n\n    stopEvent(event) {\n        return this.innerView && this.innerView.dom.contains(event.target);\n    }\n\n    ignoreMutation() { return true; }\n}\n"},"fluidObjects/prosemirror/index.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    IContainerContext,\n    IRuntime,\n    IRuntimeFactory,\n} from \"@fluidframework/container-definitions\";\nimport { ContainerRuntime } from \"@fluidframework/container-runtime\";\nimport { IFluidDataStoreFactory, FlushMode } from \"@fluidframework/runtime-definitions\";\nimport {\n    deprecated_innerRequestHandler,\n    buildRuntimeRequestHandler,\n} from \"@fluidframework/request-handler\";\nimport { defaultRouteRequestHandler } from \"@fluidframework/aqueduct\";\nimport { fluidExport as smde } from \"./prosemirror\";\n\nclass ProseMirrorFactory implements IRuntimeFactory {\n    public get IRuntimeFactory() { return this; }\n\n    public readonly defaultDataObjectName = \"@fluid-example/ProseMirror\";\n\n    public async instantiateRuntime(context: IContainerContext): Promise<IRuntime> {\n        const registry = new Map<string, Promise<IFluidDataStoreFactory>>([\n            [this.defaultDataObjectName, Promise.resolve(smde)],\n        ]);\n\n        const defaultComponentId = \"default\";\n\n        const runtime = await ContainerRuntime.load(\n            context,\n            registry,\n            buildRuntimeRequestHandler(\n                defaultRouteRequestHandler(defaultComponentId),\n                deprecated_innerRequestHandler,\n            ),\n            { generateSummaries: true });\n\n        // Flush mode to manual to batch operations within a turn\n        runtime.setFlushMode(FlushMode.Manual);\n\n        // On first boot create the base component\n        if (!runtime.existing) {\n            await runtime.createRootDataStore(this.defaultDataObjectName, defaultComponentId);\n        }\n\n        return runtime;\n    }\n}\n\nexport const fluidExport = new ProseMirrorFactory();\n\nexport const instantiateRuntime =\n    // eslint-disable-next-line @typescript-eslint/promise-function-async\n    (context: IContainerContext): Promise<IRuntime> => fluidExport.instantiateRuntime(context);\n"},"fluidObjects/prosemirror/prompt.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n// fork of prompt from prosemirror-example-setup\n\n// TODO I should swap out the menu w/ a Fabric setup\n\nconst prefix = \"ProseMirror-prompt\";\n\nexport function openPrompt(options) {\n    const wrapper = document.body.appendChild(document.createElement(\"div\"));\n    wrapper.className = prefix;\n\n    const mouseOutside = (e) => { if (!wrapper.contains(e.target)) { close(); } };\n    setTimeout(() => window.addEventListener(\"mousedown\", mouseOutside), 50);\n    const close = () => {\n        window.removeEventListener(\"mousedown\", mouseOutside);\n        if (wrapper.parentNode) { wrapper.parentNode.removeChild(wrapper); }\n    };\n\n    const domFields = [];\n    // eslint-disable-next-line guard-for-in, no-restricted-syntax\n    for (const name in options.fields) {\n        domFields.push(options.fields[name].render());\n    }\n\n    const submitButton = document.createElement(\"button\");\n    submitButton.type = \"submit\";\n    submitButton.className = `${prefix}-submit`;\n    submitButton.textContent = \"OK\";\n    const cancelButton = document.createElement(\"button\");\n    cancelButton.type = \"button\";\n    cancelButton.className = `${prefix}-cancel`;\n    cancelButton.textContent = \"Cancel\";\n    cancelButton.addEventListener(\"click\", close);\n\n    const form = wrapper.appendChild(document.createElement(\"form\"));\n    if (options.title) { form.appendChild(document.createElement(\"h5\")).textContent = options.title; }\n    domFields.forEach((field) => {\n        form.appendChild(document.createElement(\"div\")).appendChild(field);\n    });\n    const buttons = form.appendChild(document.createElement(\"div\"));\n    buttons.className = `${prefix}-buttons`;\n    buttons.appendChild(submitButton);\n    buttons.appendChild(document.createTextNode(\" \"));\n    buttons.appendChild(cancelButton);\n\n    const box = wrapper.getBoundingClientRect();\n    wrapper.style.top = `${(window.innerHeight - box.height) / 2}px`;\n    wrapper.style.left = `${(window.innerWidth - box.width) / 2}px`;\n\n    const submit = () => {\n        const params = getValues(options.fields, domFields);\n        if (params) {\n            close();\n            options.callback(params);\n        }\n    };\n\n    form.addEventListener(\"submit\", (e) => {\n        e.preventDefault();\n        submit();\n    });\n\n    form.addEventListener(\"keydown\", (e) => {\n        if (e.keyCode === 27) {\n            e.preventDefault();\n            close();\n        } else if (e.keyCode === 13 && !(e.ctrlKey || e.metaKey || e.shiftKey)) {\n            e.preventDefault();\n            submit();\n        } else if (e.keyCode === 9) {\n            window.setTimeout(() => {\n                if (!wrapper.contains(document.activeElement)) { close(); }\n            }, 500);\n        }\n    });\n\n    const input = form.elements[0] as HTMLDivElement;\n    if (input) { input.focus(); }\n}\n\nfunction getValues(fields, domFields) {\n    const result = Object.create(null);\n    let i = 0;\n    // eslint-disable-next-line guard-for-in, no-restricted-syntax\n    for (const name in fields) {\n        const field = fields[name]; const dom = domFields[i++];\n        const value = field.read(dom); const bad = field.validate(value);\n        if (bad) {\n            reportInvalid(dom, bad);\n            return null;\n        }\n        result[name] = field.clean(value);\n    }\n    return result;\n}\n\nfunction reportInvalid(dom, message) {\n    // FIXME this is awful and needs a lot more work\n    const parent = dom.parentNode;\n    const msg = parent.appendChild(document.createElement(\"div\"));\n    msg.style.left = `${dom.offsetLeft + dom.offsetWidth + 2}px`;\n    msg.style.top = `${dom.offsetTop - 5}px`;\n    msg.className = \"ProseMirror-invalid\";\n    msg.textContent = message;\n    setTimeout(() => parent.removeChild(msg), 1500);\n}\n\n// ::- The type of field that `FieldPrompt` expects to be passed to it.\nexport class Field {\n    public options;\n\n    // :: (Object)\n    // Create a field with the given options. Options support by all\n    // field types are:\n    //\n    // **`value`**`: ?any`\n    //   : The starting value for the field.\n    //\n    // **`label`**`: string`\n    //   : The label for the field.\n    //\n    // **`required`**`: ?bool`\n    //   : Whether the field is required.\n    //\n    // **`validate`**`: ?(any)  ?string`\n    //   : A function to validate the given value. Should return an\n    //     error message if it is not valid.\n    constructor(options) { this.options = options; }\n\n    // Render:: (state: EditorState, props: Object)  dom.Node\n    // Render the field to the DOM. Should be implemented by all subclasses.\n\n    // :: (dom.Node)  any\n    // Read the field's value from its DOM node.\n    read(dom) { return dom.value; }\n\n    // :: (any)  ?string\n    // A field-type-specific validation function.\n    validateType(_value): string { return; }\n\n    validate(value) {\n        if (!value && this.options.required) { return \"Required field\"; }\n        return this.validateType(value) || (this.options.validate && this.options.validate(value));\n    }\n\n    clean(value) {\n        return this.options.clean ? this.options.clean(value) : value;\n    }\n}\n\n// ::- A field class for single-line text fields.\nexport class TextField extends Field {\n    render() {\n        const input = document.createElement(\"input\");\n        input.type = \"text\";\n        input.placeholder = this.options.label;\n        input.value = this.options.value || \"\";\n        input.autocomplete = \"off\";\n        return input;\n    }\n}\n\n// ::- A field class for dropdown fields based on a plain `<select>`\n// tag. Expects an option `options`, which should be an array of\n// `{value: string, label: string}` objects, or a function taking a\n// `ProseMirror` instance and returning such an array.\nexport class SelectField extends Field {\n    render() {\n        const select = document.createElement(\"select\");\n        this.options.options.forEach((o) => {\n            const opt = select.appendChild(document.createElement(\"option\"));\n            opt.value = o.value;\n            opt.selected = o.value === this.options.value;\n            opt.label = o.label;\n        });\n        return select;\n    }\n}\n"},"fluidObjects/prosemirror/prosemirror.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { EventEmitter } from \"events\";\nimport {\n    IFluidLoadable,\n    IFluidRouter,\n    IRequest,\n    IResponse,\n    IFluidHandle,\n} from \"@fluidframework/core-interfaces\";\nimport { FluidObjectHandle, FluidDataStoreRuntime } from \"@fluidframework/datastore\";\nimport { ISharedMap, SharedMap } from \"@fluidframework/map\";\nimport {\n    IMergeTreeInsertMsg,\n    ReferenceType,\n    reservedRangeLabelsKey,\n    createMap,\n} from \"@fluidframework/merge-tree\";\nimport { IFluidDataStoreContext, IFluidDataStoreFactory, IFluidDataStoreChannel } from \"@fluidframework/runtime-definitions\";\nimport { IFluidDataStoreRuntime, IChannelFactory } from \"@fluidframework/datastore-definitions\";\nimport { SharedString } from \"@fluidframework/sequence\";\nimport { IFluidHTMLOptions, IFluidHTMLView } from \"@fluidframework/view-interfaces\";\nimport { EditorView } from \"prosemirror-view\";\nimport { nodeTypeKey } from \"./fluidBridge\";\nimport { FluidCollabManager, IProvideRichTextEditor } from \"./fluidCollabManager\";\n\nfunction createTreeMarkerOps(\n    treeRangeLabel: string,\n    beginMarkerPos: number,\n    endMarkerPos: number,\n    nodeType: string,\n): IMergeTreeInsertMsg[] {\n    const endMarkerProps = createMap<any>();\n    endMarkerProps[reservedRangeLabelsKey] = [treeRangeLabel];\n    endMarkerProps[nodeTypeKey] = nodeType;\n\n    const beginMarkerProps = createMap<any>();\n    beginMarkerProps[reservedRangeLabelsKey] = [treeRangeLabel];\n    beginMarkerProps[nodeTypeKey] = nodeType;\n\n    return [\n        {\n            seg: { marker: { refType: ReferenceType.NestBegin }, props: beginMarkerProps },\n            pos1: beginMarkerPos,\n            type: 0,\n        },\n        {\n            seg: { marker: { refType: ReferenceType.NestEnd }, props: endMarkerProps },\n            pos1: endMarkerPos,\n            type: 0,\n        },\n    ];\n}\n\nclass ProseMirrorView implements IFluidHTMLView {\n    private content!: HTMLDivElement;\n    private editorView!: EditorView;\n    private textArea!: HTMLDivElement;\n    public get IFluidHTMLView() { return this; }\n\n    public constructor(private readonly collabManager: FluidCollabManager) { }\n\n    public render(elm: HTMLElement, options?: IFluidHTMLOptions): void {\n        // Create base textarea\n        if (!this.textArea) {\n            this.textArea = document.createElement(\"div\");\n            this.textArea.classList.add(\"editor\");\n            this.content = document.createElement(\"div\");\n            this.content.style.display = \"none\";\n            this.content.innerHTML = \"\";\n        }\n\n        // Reparent if needed\n        if (this.textArea.parentElement !== elm) {\n            this.textArea.remove();\n            this.content.remove();\n            elm.appendChild(this.textArea);\n            elm.appendChild(this.content);\n        }\n\n        if (!this.editorView) {\n            this.editorView = this.collabManager.setupEditor(this.textArea);\n        }\n    }\n\n    public remove() {\n        // Maybe implement this some time.\n    }\n}\n\n/**\n * ProseMirror builds a Fluid collaborative text editor on top of the open source text editor ProseMirror.\n * It has its own implementation of IFluidLoadable and does not extend PureDataObject / DataObject. This is\n * done intentionally to serve as an example of exposing the URL and handle via IFluidLoadable.\n */\nexport class ProseMirror extends EventEmitter\n    implements IFluidLoadable, IFluidRouter, IFluidHTMLView, IProvideRichTextEditor {\n    public static async load(runtime: IFluidDataStoreRuntime, context: IFluidDataStoreContext) {\n        const collection = new ProseMirror(runtime, context);\n        await collection.initialize();\n\n        return collection;\n    }\n\n    public get handle(): IFluidHandle<this> { return this.innerHandle; }\n\n    public get IFluidLoadable() { return this; }\n    public get IFluidRouter() { return this; }\n    public get IFluidHTMLView() { return this; }\n    public get IRichTextEditor() { return this.collabManager; }\n\n    public url: string;\n    public text!: SharedString;\n    private root!: ISharedMap;\n    private collabManager!: FluidCollabManager;\n    private view!: ProseMirrorView;\n    private readonly innerHandle: IFluidHandle<this>;\n\n    constructor(\n        private readonly runtime: IFluidDataStoreRuntime,\n        /* Private */ context: IFluidDataStoreContext,\n    ) {\n        super();\n\n        this.url = context.id;\n        this.innerHandle = new FluidObjectHandle(this, this.url, runtime.IFluidHandleContext);\n    }\n\n    public async request(request: IRequest): Promise<IResponse> {\n        return {\n            mimeType: \"fluid/object\",\n            status: 200,\n            value: this,\n        };\n    }\n\n    private async initialize() {\n        if (!this.runtime.existing) {\n            this.root = SharedMap.create(this.runtime, \"root\");\n            const text = SharedString.create(this.runtime);\n\n            const ops = createTreeMarkerOps(\"prosemirror\", 0, 1, \"paragraph\");\n            text.groupOperation({ ops, type: 3 });\n            text.insertText(1, \"Hello, world!\");\n\n            this.root.set(\"text\", text.handle);\n            this.root.bindToContext();\n        }\n\n        this.root = await this.runtime.getChannel(\"root\") as ISharedMap;\n        this.text = await this.root.get<IFluidHandle<SharedString>>(\"text\").get();\n\n        this.collabManager = new FluidCollabManager(this.text, this.runtime.loader);\n\n        // Access for debugging\n        // eslint-disable-next-line dot-notation\n        window[\"easyComponent\"] = this;\n    }\n\n    public render(elm: HTMLElement): void {\n        if (!this.view) {\n            this.view = new ProseMirrorView(this.collabManager);\n        }\n        this.view.render(elm);\n    }\n}\n\nclass ProseMirrorFactory implements IFluidDataStoreFactory {\n    public static readonly type = \"@fluid-example/prosemirror\";\n    public readonly type = ProseMirrorFactory.type;\n\n    public get IFluidDataStoreFactory() { return this; }\n    public instantiateDataStore(context: IFluidDataStoreContext): Promise<IFluidDataStoreChannel> {\n        const dataTypes = new Map<string, IChannelFactory>();\n        const mapFactory = SharedMap.getFactory();\n        const sequenceFactory = SharedString.getFactory();\n\n        dataTypes.set(mapFactory.type, mapFactory);\n        dataTypes.set(sequenceFactory.type, sequenceFactory);\n\n        const runtime = FluidDataStoreRuntime.load(\n            context,\n            dataTypes,\n        );\n\n        const proseMirrorP = ProseMirror.load(runtime, context);\n        runtime.registerRequestHandler(async (request: IRequest) => {\n            const proseMirror = await proseMirrorP;\n            return proseMirror.request(request);\n        });\n        return Promise.resolve(runtime);\n    }\n}\n\nexport const fluidExport = new ProseMirrorFactory();\n"},"fluidObjects/prosemirror/selection.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Plugin } from \"prosemirror-state\";\nimport { DecorationSet, Decoration } from \"prosemirror-view\";\n\n// Sample from\n// https://github.com/PierBover/prosemirror-cookbook\n\nexport const create = () => new Plugin({\n    props: {\n        decorations(state) {\n            const selection = state.selection;\n            const resolved = state.doc.resolve(selection.from);\n            const decoration = Decoration.node(resolved.before(), resolved.after(), { class: \"selected\" });\n            // Equivalent to\n            // const decoration = Decoration.node(resolved.start() - 1, resolved.end() + 1, {class: 'selected'});\n            return DecorationSet.create(state.doc, [decoration]);\n        },\n    },\n});\n"},"fluidObjects/prosemirror/style.css":{"raw":"#editor,\n.editor {\n    background: white;\n    color: black;\n    background-clip: padding-box;\n    padding: 5px 5px;\n    min-height: 200px;\n}\n\n.ProseMirror p:first-child,\n.ProseMirror h1:first-child,\n.ProseMirror h2:first-child,\n.ProseMirror h3:first-child,\n.ProseMirror h4:first-child,\n.ProseMirror h5:first-child,\n.ProseMirror h6:first-child {\n    margin-top: 10px;\n}\n\n.ProseMirror {\n    padding: 4px 8px 4px 14px;\n    line-height: 1.2;\n    outline: none;\n    font-size: 17px;\n}\n\n.ProseMirror p {\n    margin-bottom: 1em\n}\n\n.ProseMirror {\n  counter-reset: prosemirror-footnote;\n}\n\n.ProseMirror-menubar {\n  padding: 5px 10px;\n}\n\n.ProseMirror-menuitem {\n  font-size: 15px;\n  padding: 0 3px;\n}\n\nfootnote {\n  display: inline-block;\n  position: relative;\n  cursor: pointer;\n}\n\nfootnote::after {\n  content: counter(prosemirror-footnote);\n  vertical-align: super;\n  font-size: 75%;\n  counter-increment: prosemirror-footnote;\n}\n\n.ProseMirror-hideselection .footnote-tooltip *::selection {\n  background-color: transparent;\n}\n\n.ProseMirror-hideselection .footnote-tooltip *::-moz-selection {\n  background-color: transparent;\n}\n\n.footnote-tooltip {\n  cursor: auto;\n  position: absolute;\n  left: -30px;\n  top: calc(100% + 10px);\n  background: silver;\n  padding: 3px;\n  border-radius: 2px;\n  width: 500px;\n}\n\n.footnote-tooltip::before {\n  border: 5px solid silver;\n  border-top-width: 0px;\n  border-left-color: transparent;\n  border-right-color: transparent;\n  position: absolute;\n  top: -5px;\n  left: 27px;\n  content: \" \";\n  height: 0;\n  width: 0;\n}"},"fluidObjects/sudoku/fluidSudoku.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { DataObject, DataObjectFactory } from \"@fluidframework/aqueduct\";\nimport { IFluidHandle } from \"@fluidframework/core-interfaces\";\nimport { ISharedMap, SharedMap } from \"@fluidframework/map\";\nimport { IFluidHTMLView } from \"@fluidframework/view-interfaces\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { loadPuzzle } from \"./helpers/puzzles\";\nimport { SudokuView } from \"./react/sudokuView\";\n\n// eslint-disable-next-line import/no-unassigned-import\nimport \"./helpers/styles.css\";\n\nexport const FluidSudokuName = \"FluidSudoku\";\n\n/**\n * A collaborative Sudoku component built on the Fluid Framework.\n */\nexport class FluidSudoku extends DataObject implements IFluidHTMLView {\n    public get IFluidHTMLView() {\n        return this;\n    }\n\n    /**\n     * This is where you define all which Distributed Data Structures your component will use\n     */\n    private static readonly factory = new DataObjectFactory(\n        FluidSudokuName,\n        FluidSudoku,\n        [SharedMap.getFactory()],\n        {}\n    );\n\n    public static getFactory() {\n        return FluidSudoku.factory;\n    }\n\n    private domElement: HTMLElement | undefined;\n    private readonly sudokuMapKey = \"sudoku-map\";\n    private puzzle: ISharedMap | undefined;\n    private readonly presenceMapKey = \"clientPresence\";\n    private clientPresence: ISharedMap | undefined;\n\n    /**\n     * ComponentInitializingFirstTime is where you do setup for your component. This is only called once the first time\n     * your component is created. Anything that happens in initializingFirstTime will happen before any other\n     * user will see the component.\n     */\n    protected async initializingFirstTime() {\n        // Create a new map for our Sudoku data\n        const map = SharedMap.create(this.runtime);\n\n        // Populate it with some puzzle data\n        loadPuzzle(0, map);\n\n        // Store the new map under the sudokuMapKey key in the root SharedDirectory\n        this.root.set(this.sudokuMapKey, map.handle);\n\n        // Create a SharedMap to store presence data\n        const clientPresence = SharedMap.create(this.runtime);\n        this.root.set(this.presenceMapKey, clientPresence.handle);\n    }\n\n    /**\n     * This method will be called whenever the component has initialized, be it the first time or subsequent times.\n     */\n    protected async hasInitialized() {\n        // Shared objects that are stored within other Shared objects (e.g. a SharedMap within the root, which is a\n        // SharedDirectory) must be retrieved asynchronously. We do that here, in this async function, then store a\n        // local reference to the object so we can easily use it in synchronous code.\n        //\n        // Our \"puzzle\" SharedMap is stored as a handle on the \"root\" SharedDirectory. To get it we must make a\n        // synchronous call to get the IFluidHandle, then an asynchronous call to get the ISharedMap from the\n        // handle.\n        this.puzzle = await this.root.get<IFluidHandle<ISharedMap>>(this.sudokuMapKey).get();\n\n        // Since we're using a Fluid distributed data structure to store our Sudoku data, we need to render whenever a\n        // value in our map changes. Recall that distributed data structures can be changed by both local and remote\n        // clients, so if we don't call render here, then our UI will not update when remote clients change data.\n        this.puzzle.on(\"valueChanged\", (changed, local, op) => {\n            this.render();\n        });\n\n        this.clientPresence = await this.root\n            .get<IFluidHandle<ISharedMap>>(this.presenceMapKey)\n            .get();\n\n        this.clientPresence.on(\"valueChanged\", (changed, local, op) => {\n            this.render();\n        });\n    }\n\n    public render(element?: HTMLElement): void {\n        if (element) {\n            this.domElement = element;\n        }\n        if (this.domElement) {\n            let view: JSX.Element;\n            if (this.puzzle) {\n                view = (\n                    <SudokuView\n                        puzzle={this.puzzle}\n                        clientPresence={this.clientPresence}\n                        clientId={this.runtime.clientId ?? \"not connected\"}\n                        setPresence={this.presenceSetter}\n                    />\n                );\n            } else {\n                view = <div />;\n            }\n            ReactDOM.render(view, this.domElement);\n        }\n    }\n\n    /**\n     * A function that can be used to update presence data.\n     *\n     * @param cellCoordinate - The coordinate of the cell to set.\n     * @param reset - If true, presence for the cell will be cleared.\n     */\n    private readonly presenceSetter = (cellCoordinate: string, reset: boolean): void => {\n        if (this.clientPresence) {\n            if (reset) {\n                // Retrieve the current clientId in the cell, if there is one\n                const prev = this.clientPresence.get<string>(cellCoordinate);\n                const isCurrentClient = this.runtime.clientId === prev;\n                if (!isCurrentClient) {\n                    return;\n                }\n                this.clientPresence.delete(cellCoordinate);\n            } else {\n                this.clientPresence.set(cellCoordinate, this.runtime.clientId);\n            }\n        }\n    };\n}\n"},"fluidObjects/sudoku/helpers/coordinate.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * This type wrapper around string is useful within this codebase to differentiate functions that are expecting strings\n * in a particular format - a CoordinateString - vs those that expect \"any old string.\"\n */\nexport type CoordinateString = string;\n\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport class Coordinate {\n    /**\n     * Given two numbers, returns a 2-dimensional coordinate string.\n     */\n    public static asString = (row: number, column: number): CoordinateString => `${row},${column}`;\n\n    /**\n     * Returns a 2-item array of individual coordinates as strings.\n     *\n     * @param coord - A coordinate string in the form returned by `Coordinate.asString()`.\n     */\n    public static asArray(coord: CoordinateString): string[] {\n        const arr = coord.split(\",\", 2);\n        return [arr[0], arr[1]];\n    }\n\n    /**\n     * Returns a 2-item array of individual coordinates as numbers.\n     *\n     * @param coord - A coordinate string in the form returned by `Coordinate.asString()`.\n     */\n    public static asArrayNumbers(coord: CoordinateString): number[] {\n        return Coordinate.asArray(coord).map(Number);\n    }\n\n    public static moveUp(coord: CoordinateString): CoordinateString {\n        const [row, column] = Coordinate.asArrayNumbers(coord);\n        const newRow = row - 1 < 0 ? 0 : row - 1;\n        return Coordinate.asString(newRow, column);\n    }\n\n    public static moveDown(coord: CoordinateString): CoordinateString {\n        const [row, column] = Coordinate.asArrayNumbers(coord);\n        const newRow = row + 1 < 0 ? 0 : row + 1;\n        return Coordinate.asString(newRow, column);\n    }\n\n    public static moveLeft(coord: CoordinateString): CoordinateString {\n        const [row, column] = Coordinate.asArrayNumbers(coord);\n        const newColumn = column - 1 < 0 ? 0 : column - 1;\n        return Coordinate.asString(row, newColumn);\n    }\n\n    public static moveRight(coord: CoordinateString): CoordinateString {\n        const [row, column] = Coordinate.asArrayNumbers(coord);\n        const newColumn = column + 1 > 9 ? 0 : column + 1;\n        return Coordinate.asString(row, newColumn);\n    }\n}\n"},"fluidObjects/sudoku/helpers/puzzles.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ISharedMap } from \"@fluidframework/map\";\nimport sudoku from \"sudokus\";\nimport { Coordinate } from \"./coordinate\";\nimport { SudokuCell } from \"./sudokuCell\";\n\n/**\n * An array of numbers 0-9 for convenient looping when building Sudoku grids.\n */\nexport const PUZZLE_INDEXES = Array.from(Array(9).keys());\n\nexport const PUZZLES = [\n    [\n        [0, 0, 2, 0, 6, 8, 0, 9, 7],\n        [4, 0, 6, 3, 0, 9, 0, 0, 0],\n        [0, 0, 0, 2, 0, 0, 0, 3, 5],\n        [0, 0, 7, 0, 0, 0, 0, 5, 8],\n        [6, 0, 8, 0, 0, 0, 7, 0, 4],\n        [5, 2, 0, 0, 0, 0, 9, 0, 0],\n        [1, 9, 0, 0, 0, 3, 0, 0, 0],\n        [0, 0, 0, 7, 0, 4, 8, 0, 9],\n        [8, 7, 0, 1, 9, 0, 3, 0, 0],\n    ],\n    [\n        [0, 0, 0, 2, 9, 0, 1, 0, 0],\n        [6, 0, 0, 5, 0, 1, 0, 7, 0],\n        [0, 0, 0, 0, 0, 0, 0, 3, 4],\n        [0, 0, 0, 0, 0, 0, 9, 4, 0],\n        [4, 5, 0, 3, 0, 0, 0, 6, 2],\n        [2, 0, 9, 0, 0, 4, 3, 1, 0],\n        [0, 2, 0, 0, 0, 0, 4, 9, 0],\n        [0, 0, 6, 0, 0, 8, 0, 0, 0],\n        [0, 4, 3, 0, 2, 0, 0, 8, 7],\n    ],\n];\n\n/**\n * Loads a puzzle into an ISharedMap.\n *\n * @param index - The index of the puzzle to load.\n * @param puzzleMap - The shared map that stores puzzle data.\n * @returns The solved puzzle as a 2-dimensional array.\n */\nexport function loadPuzzle(index: number, puzzleMap: ISharedMap): number[][] {\n    const puzzleInput = PUZZLES[index];\n    const solution = sudoku.solve(puzzleInput);\n\n    for (const row of PUZZLE_INDEXES) {\n        for (const col of PUZZLE_INDEXES) {\n            const key = Coordinate.asString(row, col);\n            const cell = new SudokuCell(puzzleInput[row][col], solution[row][col], key);\n            puzzleMap.set(key, cell);\n        }\n    }\n    return solution;\n}\n"},"fluidObjects/sudoku/helpers/styles.css":{"raw":":root {\n    --themePrimary: #038387;\n    --themeLighterAlt: #f0fafa;\n    --themeLighter: #c7ebec;\n    --themeLight: #9bd9db;\n    --themeTertiary: #4bb4b7;\n    --themeSecondary: #159196;\n    --themeDarkAlt: #02767a;\n    --themeDark: #026367;\n    --themeDarker: #02494c;\n    --neutralLighterAlt: #f8f8f8;\n    --neutralLighter: #f4f4f4;\n    --neutralLight: #eaeaea;\n    --neutralQuaternaryAlt: #dadada;\n    --neutralQuaternary: #d2d0ce;\n    --neutralTertiaryAlt: #c8c8c8;\n    --neutralTertiary: #bab8b7;\n    --neutralSecondary: #a3a2a0;\n    --neutralPrimaryAlt: #8d8b8a;\n    --neutralPrimary: #323130;\n    --neutralDark: #605e5d;\n    --fg: #494847;\n    --bg: #ffffff;\n}\n\n.dark-theme {\n    --themePrimary: #038387;\n    --themeLighterAlt: #f0fafa;\n    --themeLighter: #c7ebec;\n    --themeLight: #9bd9db;\n    --themeTertiary: #4bb4b7;\n    --themeSecondary: #159196;\n    --themeDarkAlt: #02767a;\n    --themeDark: #026367;\n    --themeDarker: #02494c;\n    --neutralLighterAlt: #f4f4f4;\n    --neutralLighter: #ffffff;\n    --neutralLight: #dadada;\n    --neutralQuaternaryAlt: #d0d0d0;\n    --neutralQuaternary: #c8c8c8;\n    --neutralTertiaryAlt: #282726;\n    --neutralTertiary: #2a2928;\n    --neutralSecondary: #2c2b2a;\n    --neutralPrimaryAlt: #2f2e2d;\n    --neutralPrimary: #323130;\n    --neutralDark: #31302f;\n    --fg: #f8f8f8;\n    --bg: #323130;\n}\n\n/* Component Tokens */\n.sudoku {\n    --sudoku-bg: var(--bg);\n    --sudoku-fg: var(--fg);\n    --sudoku-cell-border-color: var(--fg);\n    --sudoku-input-bg-focus: var(--themeLighterAlt);\n    --sudoku-input-fg-focus: var(--themeDarker);\n    --sudoku-input-bg: var(--bg);\n    --sudoku-input-fg: var(--fg);\n    --sudoku-input-border-color: var(--neutralQuaternary);\n    --sudoku-input-border-color-focus: var(--themePrimary);\n    --sudoku-button-bg: var(--themePrimary);\n    --sudoku-button-bg-hover: var(--themeDarker);\n    --sudoku-button-fg: var(--themeLighterAlt);\n    --sudoku-button-border-hover: var(--themeLighter);\n}\n\n.sudoku-wrapper {\n    display: inline-block;\n}\n\n.sudoku {\n    height: 100%;\n    min-height: 447px;\n    display: inline-block;\n    justify-content: center;\n    padding: 10px;\n    background: var(--sudoku-bg);\n    color: var(--sudoku-fg);\n}\n\n.sudoku-theme-select {\n    display: flex;\n    align-items: center;\n    flex-grow: 2;\n}\n\n.sudoku-theme-select label {\n    display: block;\n    font-size: 14px;\n    margin-right: 6px;\n    color: var(--fg);\n}\n\n.correct {\n    --sudoku-input-bg: #9bf49b;\n    --sudoku-input-fg: #073d07;\n    --sudoku-input-border-color: #0b6a0b;\n}\n\n.wrong {\n    --sudoku-input-bg: #e7999d;\n    --sudoku-input-fg: #a4262c;\n    --sudoku-input-border-color: #a4262c;\n}\n\n.sudoku-reset {\n    flex-grow: 1;\n}\n\n.sudoku-buttons {\n    display: flex;\n    margin-top: 8px;\n}\n\n.sudoku-load {\n    display: flex;\n    align-items: center;\n}\n\n.sudoku button {\n    background: var(--sudoku-button-bg);\n    color: var(--sudoku-button-fg);\n    border: none;\n    height: 32px;\n    padding: 0 4px;\n}\n\n.sudoku button:hover {\n    background: var(--sudoku-button-bg-hover);\n}\n\n.sudoku button:focus {\n    outline-color: var(--sudoku-button-border-hover);\n}\n\n.sudoku-load button {\n    margin-left: 8px;\n}\n\n.sudoku-cell {\n    border-color: var(--sudoku-cell-border-color);\n    height: 40px;\n    width: 40px;\n    border: none;\n    box-sizing: border-box;\n}\n\n.sudoku-input {\n    box-sizing: border-box;\n    width: 38px;\n    height: 38px;\n    font-size: 14px;\n    background: var(--sudoku-input-bg);\n    color: var(--sudoku-input-fg);\n    border-width: 1px;\n    border-style: solid;\n    border-color: var(--sudoku-input-border-color);\n    border-radius: 2px;\n    text-align: center;\n    font-family: Segoe UI Semibold;\n}\n\n.sudoku-input:focus,\n.sudoku-input.presence {\n    outline: none;\n    box-shadow: 0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132),\n        0 0.6px 1.8px 0 rgba(0, 0, 0, 0.108);\n}\n\n.sudoku-input:focus {\n    border-color: var(--sudoku-input-border-color-focus);\n    background: var(--sudoku-input-bg-focus);\n    color: var(--sudoku-input-fg-focus);\n}\n\n.sudoku-input.presence {\n    --sudoku-input-bg: #edebe9;\n    --sudoku-input-fg: #323130;\n    --sudoku-input-border-color: #3b3a39;\n}\n"},"fluidObjects/sudoku/helpers/sudokuCell.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport sudoku from \"sudokus\";\nimport { CoordinateString } from \"./coordinate\";\n\nexport enum CellState {\n    empty = \"empty\",\n    fixed = \"fixed\",\n    wrong = \"wrong\",\n    correct = \"correct\",\n}\n\n/**\n * The SudokuCell class is used to store data about a cell in the Sudoku grid. The class is intended to be\n * JSON-serialized, so static get/set methods are provided for common data manipulation needs rather than functions on a\n * class instance.\n */\nexport class SudokuCell implements sudoku.Cell {\n    /**\n     * True if the cell is one of the starting \"clues\" in the Sudoku; false otherwise.\n     */\n    public readonly fixed: boolean;\n\n    /**\n     * True if the value in the cell is correct; false otherwise.\n     */\n    public isCorrect = false;\n\n    /**\n     * Creates a new SudokuCell instance.\n     *\n     * @param value - The value of the cell to initialize. Can be any single digit 0-9. 0 indicates an empty cell.\n     * Invalid values will be treated as 0.\n     * @param correctValue - The correct (solved) value of the cell.\n     * @param coordinate - The coordinate of the cell in the grid.\n     */\n    public constructor(\n        public value: number,\n        public readonly correctValue: number,\n        public readonly coordinate: CoordinateString\n    ) {\n        if (!Number.isSafeInteger(value)) {\n            this.value = 0;\n        }\n        this.fixed = value !== 0;\n        SudokuCell.setIsCorrect(this);\n    }\n\n    public toString(): string {\n        return `SudokuCell: ${JSON.stringify(this)}`;\n    }\n\n    // The following are static methods since TypeScript properties are functions and functions aren't JSONed, and we\n    // need to be manipulate the plain JavaScript objects after they've been JSONed.\n\n    /**\n     * Sets the isCorrect property on the cell and returns the cell.\n     */\n    public static setIsCorrect(cell: SudokuCell): SudokuCell {\n        cell.isCorrect = cell.fixed || cell.value === cell.correctValue;\n        return cell;\n    }\n\n    /**\n     * Returns a string representation of the cell's value suitable for display.\n     */\n    public static getDisplayString(cell: SudokuCell): string {\n        if (cell.fixed || cell.value !== 0) {\n            return cell.value.toString();\n        }\n        return \"\";\n    }\n\n    /**\n     * Returns the appropriate CellState for the cell. This state can be used to render the cell differently.\n     */\n    public static getState(cell: SudokuCell): CellState {\n        if (cell.value === 0) {\n            return CellState.empty;\n        }\n\n        if (cell.fixed) {\n            return CellState.fixed;\n        }\n\n        if (cell.isCorrect) {\n            return CellState.correct;\n        }\n\n        return CellState.wrong;\n    }\n}\n"},"fluidObjects/sudoku/index.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ContainerRuntimeFactoryWithDefaultDataStore } from \"@fluidframework/aqueduct\";\nimport { FluidSudoku, FluidSudokuName } from \"./fluidSudoku\";\nimport { ISudokuViewProps, SudokuView } from \"./react/sudokuView\";\n\n/**\n * This does setup for the Container. The ContainerRuntimeFactoryWithDefaultDataStore also enables dynamic loading in the\n * EmbeddedComponentLoader.\n *\n * There are two important things here:\n * 1. Default Component name\n * 2. Map of string to factory for all components\n */\nexport const fluidExport = new ContainerRuntimeFactoryWithDefaultDataStore(\n    FluidSudokuName,\n    new Map([[FluidSudokuName, Promise.resolve(FluidSudoku.getFactory())]])\n);\n\nexport { FluidSudoku, FluidSudokuName, SudokuView };\nexport type { ISudokuViewProps };\n"},"fluidObjects/sudoku/react/sudokuView.tsx":{"raw":"/* eslint-disable no-fallthrough */\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ISharedMap } from \"@fluidframework/map\";\nimport React from \"react\";\nimport { Coordinate, CoordinateString } from \"../helpers/coordinate\";\nimport { loadPuzzle, PUZZLE_INDEXES } from \"../helpers/puzzles\";\nimport { CellState, SudokuCell } from \"../helpers/sudokuCell\";\n\n/**\n * Props for the SudokuView React component.\n */\nexport interface ISudokuViewProps {\n    puzzle: ISharedMap;\n    clientId: string;\n    clientPresence?: ISharedMap;\n    setPresence?(cellCoord: CoordinateString, reset: boolean): void;\n}\n\n/**\n * Renders a Sudoku grid and UI for resetting/loading puzzles and changing the theme.\n * @param props - Props for the component\n */\nexport function SudokuView(props: ISudokuViewProps): JSX.Element {\n    const [theme, setTheme] = React.useState(\"default\");\n    const handleResetButton = (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n        props.puzzle.forEach((value: SudokuCell, key: CoordinateString) => {\n            if (!value.fixed && value.value !== 0) {\n                value.value = 0;\n                props.puzzle.set(key, value);\n            }\n        });\n    };\n\n    const loadPuzzle1 = (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n        loadPuzzle(0, props.puzzle);\n    };\n\n    const loadPuzzle2 = (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n        loadPuzzle(1, props.puzzle);\n    };\n\n    return (\n        <div className={`sudoku ${theme}`}>\n            <div className=\"sudoku-wrapper\">\n                <SimpleTable {...props} />\n                <div className=\"sudoku-buttons\">\n                    <span className=\"sudoku-theme-select\">\n                        <label htmlFor=\"theme-select\">Theme: </label>\n                        <select\n                            value={theme}\n                            onChange={onThemeChange}\n                            id=\"theme-select\"\n                            name=\"theme\">\n                            <option aria-selected={theme === \"default\"} value=\"default\">\n                                Default Theme{\" \"}\n                            </option>\n                            <option aria-selected={theme === \"dark-theme\"} value=\"dark-theme\">\n                                Dark Theme\n                            </option>\n                        </select>\n                    </span>\n\n                    <span className=\"sudoku-reset\">\n                        <button onClick={handleResetButton}>Reset</button>\n                    </span>\n\n                    <span className=\"sudoku-load\">\n                        Load:\n                        <button onClick={loadPuzzle1}>Puzzle 1</button>\n                        <button onClick={loadPuzzle2}>Puzzle 2</button>\n                    </span>\n                </div>\n            </div>\n        </div>\n    );\n\n    function onThemeChange(e: any) {\n        setTheme(e.target.value);\n    }\n}\n\nfunction SimpleTable(props: ISudokuViewProps) {\n    const coordinateDataAttributeName = \"cellcoordinate\";\n\n    const getCellInputElement = (coord: CoordinateString): HTMLInputElement =>\n        document.getElementById(`${props.clientId}-${coord}`) as HTMLInputElement;\n\n    const handleInputFocus = (e: React.FocusEvent<HTMLInputElement>) => {\n        const coord = e.target.dataset[coordinateDataAttributeName];\n        if (props.setPresence) {\n            if (coord !== undefined) {\n                props.setPresence(coord, false);\n            }\n        }\n    };\n\n    const handleInputBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n        const coord = e.target.dataset[coordinateDataAttributeName];\n        if (props.setPresence) {\n            if (coord !== undefined) {\n                props.setPresence(coord, true);\n            }\n        }\n    };\n\n    const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n        e.preventDefault();\n        let keyString = e.key;\n        let coord = e.currentTarget.dataset[coordinateDataAttributeName] as string;\n        coord = coord === undefined ? \"\" : coord;\n        const cell = props.puzzle.get<SudokuCell>(coord);\n\n        switch (keyString) {\n            case \"Backspace\":\n            case \"Delete\":\n            case \"Del\":\n            case \"0\":\n                keyString = \"0\";\n            // Intentional fall-through\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n                if (cell.fixed) {\n                    return;\n                }\n                numericInput(keyString, coord);\n                return;\n            default:\n                moveCell(keyString, coord);\n                return;\n        }\n    };\n\n    const numericInput = (keyString: string, coord: string) => {\n        let valueToSet = Number(keyString);\n        valueToSet = Number.isNaN(valueToSet) ? 0 : valueToSet;\n        if (valueToSet >= 10 || valueToSet < 0) {\n            return;\n        }\n\n        if (coord !== undefined) {\n            const cellInputElement = getCellInputElement(coord);\n            cellInputElement.value = keyString;\n\n            const toSet = props.puzzle.get<SudokuCell>(coord);\n            if (toSet.fixed) {\n                return;\n            }\n            toSet.value = valueToSet;\n            toSet.isCorrect = valueToSet === toSet.correctValue;\n            props.puzzle.set(coord, toSet);\n        }\n    };\n\n    const moveCell = (keyString: string, coordIn: string) => {\n        const coord = coordIn;\n        let newCoord = coordIn;\n        switch (keyString) {\n            case \"ArrowDown\":\n            case \"s\":\n                newCoord = Coordinate.moveDown(coord);\n                break;\n            case \"ArrowUp\":\n            case \"w\":\n                newCoord = Coordinate.moveUp(coord);\n                break;\n            case \"ArrowLeft\":\n            case \"a\":\n                newCoord = Coordinate.moveLeft(coord);\n                break;\n            case \"ArrowRight\":\n            case \"d\":\n                newCoord = Coordinate.moveRight(coord);\n                break;\n            default:\n                newCoord = coord;\n        }\n\n        const newCell = getCellInputElement(newCoord);\n        newCell.focus();\n    };\n\n    const renderGridRows = () => {\n        const rows = PUZZLE_INDEXES.map(row => {\n            const columns = PUZZLE_INDEXES.map(col => {\n                const coord = Coordinate.asString(row, col);\n                const currentCell = props.puzzle.get<SudokuCell>(coord);\n                const state = SudokuCell.getState(currentCell);\n                let inputClasses: string;\n                switch (state) {\n                    case CellState.correct:\n                        inputClasses = `sudoku-input correct`;\n                        break;\n                    case CellState.wrong:\n                        inputClasses = `sudoku-input wrong`;\n                        break;\n                    default:\n                        inputClasses = `sudoku-input`;\n                }\n\n                if (props.clientPresence) {\n                    const cellOwner = props.clientPresence.get<string>(coord);\n                    if (cellOwner && cellOwner !== props.clientId) {\n                        inputClasses += \" presence\";\n                    }\n                }\n                // Const disabled = currentCell.fixed === true;\n                return (\n                    <td className=\"sudoku-cell\" key={coord} style={getCellBorderStyles(coord)}>\n                        <input\n                            id={`${props.clientId}-${coord}`}\n                            className={inputClasses}\n                            type=\"text\"\n                            readOnly={true}\n                            onFocus={handleInputFocus}\n                            onBlur={handleInputBlur}\n                            onKeyDown={handleKeyDown}\n                            value={SudokuCell.getDisplayString(currentCell)}\n                            max={1}\n                            // Disabled={disabled}\n                            data-cellcoordinate={coord}\n                        />\n                    </td>\n                );\n            });\n            return <tr key={row.toString()}>{columns}</tr>;\n        });\n        return rows;\n    };\n\n    return (\n        <table style={{ border: \"none\" }}>\n            <tbody>{renderGridRows()}</tbody>\n        </table>\n    );\n}\n\n/**\n * Returns CSS border properties to use when rendering a cell. This helps give the grid that authentic Sudoku look.\n */\nfunction getCellBorderStyles(coord: CoordinateString): React.CSSProperties {\n    const borderStyle = \"solid medium\";\n    const styles: React.CSSProperties = {\n        borderTop: \"none\",\n        borderBottom: \"none\",\n        borderLeft: \"none\",\n        borderRight: \"none\",\n        borderColor: \"var(--neutralPrimaryAlt)\",\n    };\n    const [row, col] = Coordinate.asArrayNumbers(coord);\n\n    switch (row) {\n        case 0:\n        case 3:\n        case 6:\n            styles.borderTop = borderStyle;\n            styles.paddingTop = 4;\n            break;\n        case 2:\n        case 5:\n        case 8:\n            styles.borderBottom = borderStyle;\n            styles.paddingBottom = 4;\n            break;\n        default: // Nothing\n    }\n\n    switch (col) {\n        case 0:\n        case 3:\n        case 6:\n            styles.borderLeft = borderStyle;\n            styles.paddingLeft = 4;\n            break;\n        case 2:\n        case 5:\n        case 8:\n            styles.borderRight = borderStyle;\n            styles.paddingRight = 4;\n            break;\n        default: // Nothing\n    }\n    return styles;\n}\n"},"fluidObjects/table/TableModel.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport {\n    ContainerRuntimeFactoryWithDefaultDataStore,\n    DataObject,\n    DataObjectFactory,\n} from \"@fluidframework/aqueduct\";\nimport { IFluidHTMLView } from \"@fluidframework/view-interfaces\";\nimport { SharedMatrix } from \"@fluidframework/matrix\";\nimport { IFluidHandle } from \"@fluidframework/core-interfaces\";\nimport { IMatrixConsumer, IMatrixProducer } from \"@tiny-calc/nano\";\nimport { IFluidTable } from \"./interface\";\nimport { TableView } from \"./TableView\";\n\nconst matrixDataStoreKey = \"matrixDataStoreKey\";\n\nexport class FluidTable extends DataObject implements IFluidTable, IFluidHTMLView, IMatrixConsumer<string> {\n    public get IFluidHTMLView() {\n        return this;\n    }\n\n    static get FluidObjectName() { return \"@fluid-example/Fluid Table\"; }\n\n    private _matrixData!: SharedMatrix<string>;\n\n    static factory = new DataObjectFactory(\n        FluidTable.FluidObjectName,\n        FluidTable,\n        [SharedMatrix.getFactory()],\n        {},\n    );\n\n    protected async initializingFirstTime() {\n        const matrixDDSObject = SharedMatrix.create(this.runtime);\n\n        // Insert 4 rows and 4 columns.\n        matrixDDSObject.insertRows(0, 4);\n        matrixDDSObject.insertCols(0, 4);\n\n        // Set column titles in the first row.\n        matrixDDSObject.setCell(0, 0, \"Column 1\");\n        matrixDDSObject.setCell(0, 1, \"Column 2\");\n        matrixDDSObject.setCell(0, 2, \"Column 3\");\n        matrixDDSObject.setCell(0, 3, \"Column 4\");\n\n        this.root.set(matrixDataStoreKey, matrixDDSObject.handle);\n    }\n\n    protected async hasInitialized() {\n        const matrixDDSObjectHandle = this.root.get<IFluidHandle<SharedMatrix<string>>>(matrixDataStoreKey);\n        this._matrixData = await matrixDDSObjectHandle.get();\n\n        // Call 'openMatrix' to observe changes in the SharedMatrix.\n        this._matrixData.openMatrix(this);\n        this.setMaxListeners(Number.MAX_SAFE_INTEGER);\n    }\n\n    /**\n     * Will return a new Table view\n     */\n    public render(div: HTMLElement) {\n        ReactDOM.render(\n            <TableView model={this} />,\n            div,\n        );\n        return div;\n    }\n\n    // IFluidTable methods\n    public get rows(): number {\n        return this._matrixData.rowCount;\n    }\n\n    public insertRows(rowStart: number, count: number) {\n        this._matrixData.insertRows(rowStart, count);\n    }\n\n    public get cols(): number {\n        return this._matrixData.colCount;\n    }\n\n    public insertCols(colStart: number, count: number) {\n        this._matrixData.insertCols(colStart, count);\n    }\n\n    public getCell(row: number, col: number): string | undefined | null {\n        return this._matrixData.getCell(row, col);\n    }\n\n    public setCell(row: number, col: number, value: string) {\n        this._matrixData.setCell(row, col, value);\n    }\n\n    // IMatrixConsumer methods which will be called back when SharedMatrix changes. We will emit events which the\n    // Table view listens to.\n    public rowsChanged(rowStart: number, removedCount: number, insertedCount: number, producer: IMatrixProducer<string>) {\n        this.emit(\"rowsChanged\", this.rows);\n    }\n\n    public colsChanged(colStart: number, removedCount: number, insertedCount: number, producer: IMatrixProducer<string>) {\n        this.emit(\"colsChanged\", this.cols);\n    }\n\n    public cellsChanged(rowStart: number, colStart: number, rowCount: number, colCount: number, producer: IMatrixProducer<string>) {\n        this.emit(\"cellChanged\", rowStart, colStart, this.getCell(rowStart, colStart));\n    }\n}\n\nexport const TableContainerFactory = new ContainerRuntimeFactoryWithDefaultDataStore(\n    FluidTable.FluidObjectName,\n    [[FluidTable.FluidObjectName, Promise.resolve(FluidTable.factory)]]\n  );\n"},"fluidObjects/table/TableView.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport React, {useState} from \"react\";\nimport { IFluidTable } from \"./interface\";\nimport \"./styles.css\";\n\ninterface TableViewProps {\n    model: IFluidTable;\n};\n\ninterface TableViewState {\n    rowCount: number;\n    colCount: number;\n};\n\nexport class TableView extends React.Component<TableViewProps, TableViewState> {\n\n    constructor(props: TableViewProps) {\n        super(props);\n\n        this.state = {\n            rowCount: this.props.model.rows,\n            colCount: this.props.model.cols,\n        };\n    }\n\n    componentDidMount() {\n        // Set up event listener to observe when the number of rows and columns change.\n        this.props.model.on(\"rowsChanged\", (rowCount: number) => {\n            this.setState({rowCount});\n        });\n\n        this.props.model.on(\"colsChanged\", (colCount: number) => {\n            this.setState({colCount});\n        });\n    }\n\n    addRow = () => {\n        // Insert a new row in the data model.\n        this.props.model.insertRows(this.props.model.rows, 1);\n    }\n\n    render() {\n        const { rowCount, colCount } = this.state;\n        const rows = [];\n        for (let i = 0; i < rowCount; i++) {\n            const cells = []\n            for(let j=0;j< colCount;j++){\n                cells.push(<Cell model={this.props.model} rowIndex={i} colIndex={j} key={`row_${i}_col_${j}`}/>)\n            }\n            rows.push(<div className={`row ${i === rowCount-1 ? 'row-last': ''}`} key={`row_${i}`}>{cells}</div>)\n        }\n\n        return (\n            <div className='table'>\n                {rows}\n                <div className='actions'><button onClick={this.addRow}>+</button></div>\n            </div>\n        )\n    }\n}\n\ninterface CellProps {\n    model: IFluidTable;\n    rowIndex: number;\n    colIndex: number;\n};\n\nconst Cell = function Cell(props: CellProps) {\n    const { model, rowIndex, colIndex } = props;\n    const [cellContent, setCellContent] = useState(model.getCell(rowIndex, colIndex));\n    const [insertMode, setInsertMode] = useState(false);\n\n    const onCellClicked = (e: any) => {\n        e.target.focus();\n        setInsertMode(true);\n    }\n\n    const onBlurCell = (e: any) => {\n        setInsertMode(false);\n        setCellContent(e.target.textContent);\n\n        // Update the data model with the new cell contents.\n        model.setCell(rowIndex, colIndex, e.target.textContent);\n    }\n\n    // Set up event listener to observe when the cell data changes.\n    model.on(\"cellChanged\", (row: number, col: number, value: string) => {\n        if (row === rowIndex && col === colIndex) {\n            setCellContent(value);\n        }\n    });\n\n    return (\n        <div className={`cell ${rowIndex === 0 ? 'cell-title' : ''} ${colIndex === model.cols-1 ? 'cell-last-col' : ''}`} onClick={onCellClicked} onBlur={onBlurCell} contentEditable={insertMode}>\n            {cellContent}\n        </div>\n    );\n};"},"fluidObjects/table/interface.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { EventEmitter } from \"events\";\n\n/**\n * IFluidTable describes the public API surface for the FluidTable data object.\n */\nexport interface IFluidTable extends EventEmitter {\n    /**\n     * Returns the number of rows in the table.\n     */\n    readonly rows: number;\n\n    /**\n     * Returns the number of columns in the table.\n     */\n    readonly cols: number;\n\n    /**\n     * Returns the value in the cell at row number `row` and column number `col`.\n     */\n    getCell(row: number, col: number): string | undefined | null;\n\n    /**\n     * Inserts `count` number of rows starting at `rowStart`.\n     */\n    insertRows(rowStart: number, count: number): void;\n\n    /**\n     * Inserts `count` number of columns starting at `colStart`.\n     */\n    insertCols(colStart: number, count: number): void;\n\n    /**\n     * Sets a value in the cell at row number `row` and column number `col`.\n     */\n    setCell(row: number, col: number, value: string): void;\n\n    /**\n     * This event is fired when the number of rows in the table changes.\n     */\n    on(event: \"rowsChanged\", listener: (rows: number) => void): this;\n\n    /**\n     * This event is fired when the number of columns in the table changes.\n     */\n    on(event: \"colsChanged\", listener: (cols: number) => void): this;\n\n    /**\n     * This event is fired when the value change in the cell at row number `row` and column number `col`.\n     */\n    on(event: \"cellChanged\", listener: (row: number, col: number, value: string) => void): this;\n}\n"},"fluidObjects/table/styles.css":{"raw":".table {\n    margin-right: 40px;\n}\n\n.row {\n    display: flex;\n    border-top: 1px solid lightgray;\n}\n\n.row-last{\n    border-bottom: 1px solid lightgray;\n}\n\n.cell-title {\n    background-color: lightblue;\n    font-weight: bold;\n}\n\n.cell {\n    border-left: 1px solid lightgray;\n    width: 200px;\n    height: 35px;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 14px;\n}\n\n.cell-last-col{\n    border-right: 1px solid lightgray;\n}\n\n.actions {\n    margin-top: 5px;\n}\n\n.actions button {\n    border: 1px solid lightgray;\n    padding: 5px 10px;\n    border-radius: 2px;\n    background: lightblue;\n}"},"fluidRendering/fluidLoader.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport React, { useEffect, useRef } from 'react';\nimport { v4 as uuid } from \"uuid\";\nimport {\n    IFluidCodeDetails,\n    IProvideRuntimeFactory,\n} from \"@fluidframework/container-definitions\";\nimport { Container } from '@fluidframework/container-loader';\nimport { requestFluidObject } from \"@fluidframework/runtime-utils\";\nimport { getLoader, RouteOptions } from './loader';\nimport { renderFluidDataObjects } from './renderer';\n\nexport interface FluidLoaderProps {\n    factory: IProvideRuntimeFactory,\n    title: string,\n    layout?: string,\n    view?: any,\n    viewType?: string,\n}\n\nexport const FluidLoader = (props: React.PropsWithChildren<FluidLoaderProps>) => { \n    const fluidNodeRef = useRef<HTMLDivElement>(null);\n\n    useEffect(() => {\n        async function render() {\n            // Empty string means get the default DataObject from container\n            // You could also grab a specific data object from the container using \"nameOfDataObject\"\n            // For example in DiceRoller you could use \"@fluid-example/dice-roller\"\n            const dataObjectName = \"\";\n            let options: RouteOptions = { mode: \"local\" };\n\n            // Create a new Container.\n            const container1 = await createFluidContainer(props.factory, options);\n            // Get the Fluid DataObject from the first Container.\n            const fluidDataObject1 = await requestFluidObject(container1, dataObjectName);\n\n            // Load a second Container from the Container that we created above.\n            const container2 = await loadFluidContainer(props.factory, container1, options);\n            // Get the Fluid DataObject from the second Container.\n            const fluidDataObject2 = await requestFluidObject(container2, dataObjectName);\n\n            // Handle rendering\n            let fluidNode = await renderFluidDataObjects(props, fluidDataObject1, fluidDataObject2) as HTMLElement;\n            fluidNodeRef.current?.appendChild(fluidNode);\n        }\n        render();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [])\n\n    // Return initial HTML. Fluid node will be appended after useEffect is processed.\n    return (\n        <div id=\"fluid-container\">\n            <br />\n            <div ref={fluidNodeRef}></div>\n        </div>\n    );\n};\n\n// A cache of the document id per fluid runtime factory.\nconst documentIdCache = new Map<IProvideRuntimeFactory, string>();\n\n/**\n * Creates a Loader and a Container.\n * If we already have a documentId for the given factory, we use it to load an existing Container.\n * Otherwise, we create a new Container and attach it.\n * @param factory - The runtime factory for this Container.\n * @param options - The RouteOptions that specify which server to use.\n */\nasync function createFluidContainer(\n    factory: IProvideRuntimeFactory,\n    options: RouteOptions,\n): Promise<Container> {\n    // Check if we already have created a document for this Fluid factory in this session. If so, load the\n    // existing document instead of creating a new one.\n    let createDocument: boolean = false;\n    let documentId = documentIdCache.get(factory);\n    if (documentId === undefined) {\n        // A document does not exist for this session. Create a documentId to be used to create a new document\n        // and set the 'createDocument' flag to true.\n        documentId = uuid();\n        documentIdCache.set(factory, documentId);\n        createDocument = true;\n    }\n\n    let container: Container;\n    // Create a Loader for the first client.\n    const { loader, urlResolver } = await getLoader(factory, documentId, options);\n    // If the 'createDocument' flag is set, create a new container. Otherwise, load an existing one with the 'documentId'.\n    if (createDocument) {\n        const codeDetails: IFluidCodeDetails = {\n            package: \"storybook-pkg\",\n            config: {},\n        };\n\n        container = await loader.createDetachedContainer(codeDetails);\n        const attachUrl = await urlResolver.createRequestForCreateNew(documentId);\n        await container.attach(attachUrl);\n    } else {\n        const documentLoadUrl = `${window.location.origin}/${documentId}`;\n        container = await loader.resolve({ url: documentLoadUrl });\n    }\n\n    return container;\n}\n\n/**\n * Creates a Loader and loads an existing Container.\n * @param factory - The runtime factory for this Container.\n * @param fromContainer - The Container from which the new Container is to be created.\n * @param options - The RouteOptions that specify which server to use.\n */\nasync function loadFluidContainer(\n    factory: IProvideRuntimeFactory,\n    fromContainer: Container,\n    options: RouteOptions,\n): Promise<Container> {\n    const { loader, urlResolver } = await getLoader(factory, fromContainer.id, options);\n    const documentLoadUrl = await urlResolver.getAbsoluteUrl(fromContainer.resolvedUrl, \"\");\n    const container = await loader.resolve({ url: documentLoadUrl });\n\n    return container;\n}\n\n// LEAVE THE FOLLOWING FUNCTION\n// function convertToTitle(value: string) {\n//     if (value) {\n//         value = value.replace('@fluid-example/', '');\n//         value = value.replace(/-/g, ' ');\n//         let splitWords = value.split(' ');\n//         if (splitWords.length) {\n//             for (let i=0;i<splitWords.length;i++) {\n//                 splitWords[i] = splitWords[i].charAt(0).toUpperCase() + splitWords[i].slice(1);\n//             }\n//             return splitWords.join(' ');\n//         }\n//     }\n//     return value;\n// }\n"},"fluidRendering/loader.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { IProvideRuntimeFactory, IProxyLoaderFactory } from \"@fluidframework/container-definitions\";\nimport { Loader } from '@fluidframework/container-loader';\nimport { getDocumentServiceFactory } from \"./multiDocumentServiceFactory\";\nimport { MultiUrlResolver } from \"./multiResolver\";\nimport { StorybookCodeLoader } from './storybookCodeLoader';\n\nexport interface ILocalRouteOptions {\n    mode: \"local\";\n}\n\nexport interface ITinyliciousRouteOptions {\n    mode: \"tinylicious\";\n}\n\nexport type RouteOptions =\n    | ILocalRouteOptions\n    | ITinyliciousRouteOptions;\n\nexport async function getLoader(\n    factory: IProvideRuntimeFactory,\n    documentId: string,\n    options: RouteOptions,\n) {\n    const urlResolver = new MultiUrlResolver(window.location.origin, documentId, options);\n\n    const codeLoader = new StorybookCodeLoader(factory);\n    const documentServiceFactory = getDocumentServiceFactory(documentId, options);\n    const loader = new Loader(\n        urlResolver,\n        documentServiceFactory,\n        codeLoader,\n        { blockUpdateMarkers: true },\n        {},\n        new Map<string, IProxyLoaderFactory>());\n\n    return { loader, urlResolver };\n}\n"},"fluidRendering/multiDocumentServiceFactory.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { MultiDocumentServiceFactory } from \"@fluidframework/driver-utils\";\nimport { LocalDocumentServiceFactory, LocalSessionStorageDbFactory } from \"@fluidframework/local-driver\";\nimport { RouterliciousDocumentServiceFactory, DefaultErrorTracking } from \"@fluidframework/routerlicious-driver\";\nimport { ILocalDeltaConnectionServer, LocalDeltaConnectionServer } from \"@fluidframework/server-local-server\";\nimport { RouteOptions } from \"./loader\";\n\nconst localServerList = new Map<string, ILocalDeltaConnectionServer>();\n\nexport function getDocumentServiceFactory(documentId: string, options: RouteOptions) {\n    const localServer = localServerList.get(documentId) ??\n        LocalDeltaConnectionServer.create(new LocalSessionStorageDbFactory(documentId));\n        localServerList.set(documentId, localServer);\n\n    return MultiDocumentServiceFactory.create([\n        new LocalDocumentServiceFactory(localServer),\n        new RouterliciousDocumentServiceFactory(\n            false,\n            new DefaultErrorTracking(),\n            false,\n            true,\n            undefined,\n        ),\n    ]);\n}\n"},"fluidRendering/multiResolver.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n// eslint-disable-next-line import/no-internal-modules\nimport { v4 as uuid } from \"uuid\";\nimport { IRequest } from \"@fluidframework/core-interfaces\";\nimport { IResolvedUrl, IUrlResolver } from \"@fluidframework/driver-definitions\";\nimport { LocalResolver } from \"@fluidframework/local-driver\";\nimport { IUser } from \"@fluidframework/protocol-definitions\";\nimport { getRandomName } from \"@fluidframework/server-services-client\";\nimport { InsecureUrlResolver } from \"@fluidframework/test-runtime-utils\";\n\nexport interface IDevServerUser extends IUser {\n    name: string;\n}\n\nexport const tinyliciousUrls = {\n    hostUrl: \"http://localhost:3000\",\n    ordererUrl: \"http://localhost:3000\",\n    storageUrl: \"http://localhost:3000\",\n};\n\nconst getUser = (): IDevServerUser => ({\n    id: uuid(),\n    name: getRandomName(),\n});\n\nfunction getUrlResolver(\n    options: any,\n): IUrlResolver {\n    switch (options.mode) {\n        case \"tinylicious\":\n            return new InsecureUrlResolver(\n                tinyliciousUrls.hostUrl,\n                tinyliciousUrls.ordererUrl,\n                tinyliciousUrls.storageUrl,\n                \"tinylicious\",\n                \"12345\",\n                getUser(),\n                options.bearerSecret);\n\n        default: // Local\n            return new LocalResolver();\n    }\n}\n\nexport class MultiUrlResolver implements IUrlResolver {\n    private readonly urlResolver: IUrlResolver;\n    constructor(\n        private readonly rawUrl: string,\n        private readonly documentId: string,\n        private readonly options: any) {\n        this.urlResolver = getUrlResolver(options);\n    }\n\n    async getAbsoluteUrl(resolvedUrl: IResolvedUrl, relativeUrl: string): Promise<string> {\n        let url = relativeUrl;\n        if (url.startsWith(\"/\")) {\n            url = url.substr(1);\n        }\n        return `${this.rawUrl}/${this.documentId}/${url}`;\n    }\n\n    async resolve(request: IRequest): Promise<IResolvedUrl | undefined> {\n        return this.urlResolver.resolve(request);\n    }\n\n    public async createRequestForCreateNew(\n        fileName: string,\n    ): Promise<IRequest> {\n        switch (this.options.mode) {\n            case \"tinylicious\":\n                return (this.urlResolver as InsecureUrlResolver).createCreateNewRequest(fileName);\n            default: // Local\n                return (this.urlResolver as LocalResolver).createCreateNewRequest(fileName);\n        }\n    }\n}"},"fluidRendering/renderer.tsx":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { IFluidObject } from \"@fluidframework/core-interfaces\";\nimport { HTMLViewAdapter } from \"@fluidframework/view-adapters\";\nimport { FluidLoaderProps } from \"./fluidLoader\";\n\nexport async function renderFluidDataObjects(\n    props: FluidLoaderProps,\n    dataObject1: IFluidObject,\n    dataObject2: IFluidObject,\n) {\n    return new Promise(async (resolve, reject) => {\n        // Create container div that Fluid object will be rendered into for server demos\n        return await renderFluidObjectsDivs(props, dataObject1, dataObject2, resolve);\n    });\n    \n}\n\nasync function renderFluidObjectsDivs(\n    props: FluidLoaderProps,\n    dataObject1: IFluidObject,\n    dataObject2: IFluidObject,\n    resolve: any,\n) {\n    // Use horizonal layout by default\n    const divs = getDivs(props.layout ?? \"horizontal\");\n\n    if (props.view) {\n        // Convert props value to enum to ensure they pass allowed value\n        switch (props.viewType) {\n            case 'js':\n                return createDomView(props, dataObject1, dataObject2, divs, resolve);\n            case 'react':\n                return createReactView(props, dataObject1, dataObject2, divs, resolve);\n        }\n    }\n    else {\n        // Fluid object has it's own render() function\n        await renderFluidObject(dataObject1, divs.div1 as HTMLDivElement);\n        await renderFluidObject(dataObject2, divs.div2 as HTMLDivElement);\n        return resolve(divs.containerDiv);\n    }\n}\n\nasync function createDomView(\n    props: FluidLoaderProps,\n    dataObject1: IFluidObject,\n    dataObject2: IFluidObject,\n    divs: any,\n    resolve: any,\n) {\n    // Create side by side view of Fluid object for local demos\n    let leftFluidObject = new props.view(dataObject1, divs.div1);\n    leftFluidObject.render();\n    let rightFluidObject = new props.view(dataObject2, divs.div2);\n    rightFluidObject.render();\n    return resolve(divs.containerDiv);\n}\n\nasync function createReactView(props: FluidLoaderProps,\n    dataObject1: IFluidObject,\n    dataObject2: IFluidObject,\n    divs: any,\n    resolve: any,\n) {\n    ReactDOM.render(<props.view model={dataObject1} {...props} />, divs.div1);\n    ReactDOM.render(<props.view model={dataObject2} {...props} />, divs.div2);\n    return resolve(divs.containerDiv);\n}\n\nasync function renderFluidObject(dataObject: IFluidObject, div: HTMLDivElement) {\n    // We should be retaining a reference to mountableView long-term, so we can call unmount() on it to correctly\n    // remove it from the DOM if needed.\n    // SamsNotes: Typically I'd rather this get moved into HTMLViewAdapter, create something like UMD\n    // https://github.com/umdjs/umd\n    if (dataObject.IFluidMountableView) {\n        dataObject.IFluidMountableView.mount(div);\n        return;\n    }\n\n    const view = new HTMLViewAdapter(dataObject);\n    view.render(div, { display: \"block\" });\n}\n\nexport function getDivs(layout: string) {\n    const containerDiv = document.createElement('div');\n    const div1Container = makeBrowserShellDiv(\"sbs-left\", layout);\n    const div1 = div1Container.querySelector(\".browser .body\");\n    const div2Container = makeBrowserShellDiv(\"sbs-right\", layout);\n    const div2 = div2Container.querySelector(\".browser .body\");\n    \n    if (layout === 'vertical') {\n        const br = document.createElement('br');\n        containerDiv.append(div1Container, br, div2Container);\n    }\n    else {\n        containerDiv.style.display = \"flex\";\n        containerDiv.append(div1Container, div2Container);\n    }\n\n    return { div1, div2, containerDiv };\n}\n\nfunction makeBrowserShellDiv(divId: string, layout: string) {\n    const isWindows = navigator.platform.indexOf('Win') > -1;\n    const macControls = (isWindows) ? 'none': 'inline-block';\n    const windowsControls = (isWindows) ? 'inline-block': 'none';\n    const html = `\n    <div class=\"window browser\">\n        <div class=\"header\">\n            <span class=\"bullets mac\" style=\"display:${macControls}\">\n                <span class=\"bullet bullet-red\"></span>\n                <span class=\"bullet bullet-yellow\"></span>\n                <span class=\"bullet bullet-green\"></span>\n            </span>\n            <span class=\"title\">\n                <span class=\"scheme\">https://</span>your-fluid-app.com\n            </span>\n            <span class=\"windows\" style=\"display:${windowsControls}\">\n                <span class=\"windows-icon\"><div class=\"windows-min-icon\"></div></span>\n                <span class=\"windows-icon\"><div class=\"windows-max-icon\"></div></span>\n                <span class=\"windows-icon windows-close-icon\">x</span>\n            </span>\n        </div>\n        <div class=\"body\">\n            \n        </div>\n    </div> \n    `;\n    const div = document.createElement(\"div\");\n    div.innerHTML = html;\n    div.id = divId;\n    if (layout !== 'vertical') {\n        div.classList.add('flex');\n    }\n    return div;\n}"},"fluidRendering/storybookCodeLoader.ts":{"raw":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n  ICodeLoader,\n  IFluidCodeDetails,\n  IProvideRuntimeFactory,\n} from \"@fluidframework/container-definitions\";\n\nexport class StorybookCodeLoader implements ICodeLoader {\n  private readonly factory: IProvideRuntimeFactory;\n\n  constructor(factory: IProvideRuntimeFactory) {\n    this.factory = factory;\n  }\n\n  public load(source: IFluidCodeDetails) {\n    // Normally the \"source\" parameter would be the package details.\n    return Promise.resolve({\n      fluidExport: this.factory.IRuntimeFactory,\n    });\n  }\n\n}"},"stories/0.welcome.stories.mdx":{"raw":"import { Meta } from '@storybook/addon-docs/blocks';\n\n<Meta title=\"Welcome\" parameters={{ previewTabs: { 'canvas': { hidden: true }, 'fluid/sourcecode-addon/panel': {hidden: true} }} } />\n\n# Welcome to the Fluid Framework Playground\n\nThe Fluid Framework is a real-time collaboration technology that can be used to sync state between multiple users.\nThe playground provides a way to interact with Fluid objects running side by side in the browser, see what's possible,\nand even explore the source code for the demos. \n\nWhen viewing a demo you can perform the following actions:\n\n* View a demo on its own by clicking the **Canvas tab**.\n* Get details about a demo by clicking the **Docs tab**. \n* View the source code for a demo by clicking the **Source tab**. If you want to view additional files you can select one from the drop-down \nand even drill down into the code by clicking on supported `import` statements.\n\n**To get started** select a demo from the left sidebar!\n\nNote: Additional demos for other libraries/frameworks will be coming in the future.\n\n<br />\n\n<img src=\"./fluid-collab.gif\" />\n"},"stories/badge.stories.mdx":{"raw":"import { Story, Meta } from '@storybook/addon-docs/blocks';\nimport { FluidLoader } from '../fluidRendering/fluidLoader';\nimport { Badge, BadgeContainerFactory } from '../fluidObjects/badge/badgeModel';\n\n<Meta title=\"React Demos/Badge\" parameters={{ defaultSrcFile: './src/fluidObjects/badge/badgeModel.tsx'}} />\n\n# Badge Demo\n\nThis example demonstrates a badge data object that can be used to collaboratively update the status of a document. It allows multiple\nusers to collaborate in real-time on the status of a document. Select an option from the drop-down\nand you'll see that it is passed in real-time to the other collaborator.\n\n<a href=\"https://fluidframework.com/docs/concepts/dds/\" target=\"_blank\">Distributed data structures</a> (DDSes) used include:\n\n* <a href=\"https://fluidframework.com/apis/map/sharedmap/\" target=\"_blank\">SharedMap</a>\n* <a href=\"https://fluidframework.com/apis/cell/sharedcell/\" target=\"_blank\">SharedCell</a>\n* <a href=\"https://fluidframework.com/apis/sequence/sharedobjectsequence/\" target=\"_blank\">SharedObjectSequence</a>\n\n<Story name=\"Demo\">\n  <FluidLoader factory={BadgeContainerFactory} title={Badge.factory.type}></FluidLoader>\n</Story>\n\n<br /><br />\n\n### Code Highlights\n\nHere are a few highlights of how SharedMap, SharedCell, and SharedObjectSequence are used in this example. Click the **Source** tab above to \nview all of the code.\n\n```typescript\n// badge/badgeModel.ts\n\n// Define DDS properties\ncurrentCell!: SharedCell;\noptionsMap!: SharedMap;\nhistorySequence!: SharedObjectSequence<IBadgeHistory>;\n\n...\n\n// Creating DDSes\nprotected async initializingFirstTime() {\n    // Create a cell to represent the Badge's current state\n    const current = SharedCell.create(this.runtime);\n    this.root.set(this.currentId, current.handle);\n\n    // Create a map to represent the options for the Badge\n    const options = SharedMap.create(this.runtime);\n    this.root.set(this.optionsId, options.handle);\n\n    // Create a sequence to store the badge's history\n    const badgeHistory = SharedObjectSequence.create<IBadgeHistory>(this.runtime);\n    this.root.set(this.historyId, badgeHistory.handle);\n}\n\n...\n\n// Accessing DDSes\nprotected async hasInitialized() {\n    [ this.currentCell, this.optionsMap, this.historySequence ] = await Promise.all([\n        this.root.get<IFluidHandle<SharedCell>>(this.currentId).get(),\n        this.root.get<IFluidHandle<SharedMap>>(this.optionsId).get(),\n        this.root.get<IFluidHandle<SharedObjectSequence<IBadgeHistory>>>(this.historyId).get(),\n    ]);\n}\n\n...\n\n// Using DDSes - badge/badgeClient.tsx\nconst changeSelectedOption = (newItem: IBadgeType): void => {\n    if (newItem.key !== model.currentCell.get().key) {\n        // SharedObjectSequence DDS\n        const len = model.historySequence.getItemCount();\n        model.historySequence.insert(len, [\n            {\n                value: newItem,\n                timestamp: new Date(),\n            },\n        ]);\n        // SharedCell DDS\n        model.currentCell.set(newItem);\n    }\n};\n\nconst getOptions = () => {\n    // SharedMap DDS\n    // Spread iterable out into an array\n    return [...model.optionsMap.values()];\n};\n\n...\n\n// Handling DDS changes\nReact.useEffect(() => {\n    // Watch for Fluid data updates and update React state\n    model.currentCell.on(\"valueChanged\", () => {\n        setSelectedOption(getSelectedOptionKey());\n        setHistoryItems(getHistoryItems());\n    });\n}, [getHistoryItems, getSelectedOptionKey, model.currentCell]);\n\n```\n\n### Additional Resources\n\n* <a href=\"https://github.com/microsoft/FluidFramework/tree/main/examples/data-objects/badge\" target=\"_blank\">Badge Repository</a>\n"},"stories/brainstorm.stories.mdx":{"raw":"import { Story, Meta } from '@storybook/addon-docs/blocks';\nimport { FluidLoader } from '../fluidRendering/fluidLoader';\nimport {\n  NoteroContainerFactory,\n  NoteroInstantiationFactory,\n  NoteroView,\n} from \"../fluidObjects/brainstorm\";\n\n<Meta title=\"React Demos/Brainstorm\" parameters={{ defaultSrcFile: './src/fluidObjects/brainstorm/fluid-object/main.ts'}} />\n\n# Brainstorm\n\nThis example demonstrates a simple idea sharing board. Users can create a \"sticky note\" with an idea\non it and then add it to the board. Connected users will automatically see the new sticky note and are able\nto create and share sticky notes of their own. As notes are added, all connected users can\nvote on the proposed sticky note ideas and can highlight their own ideas.\n\n<a href=\"https://fluidframework.com/docs/concepts/dds/\" target=\"_blank\">Distributed data structures</a> used include:\n\n* <a href=\"https://fluidframework.com/apis/map/sharedmap/\" target=\"_blank\">SharedMap</a>\n\n<Story name=\"Demo\">\n  <FluidLoader factory={NoteroContainerFactory} title={NoteroInstantiationFactory.type} view={NoteroView} viewType=\"react\"></FluidLoader>\n</Story>\n\n<br /><br />\n\n### Code Highlights\n\nHere are a few highlights of how SharedMap is used in this example. Click the **Source** tab above to view all of the code.\n\n```typescript\n// brainstorm/fluid-object/main.ts\n// Define DDS property\nprivate notesMap: SharedMap;\n\n...\n\n// Create a DDS\nprivate createSharedMap(id: string): void {\n    const map = SharedMap.create(this.runtime);\n    this.root.set(id, map.handle);\n}\n\nthis.createSharedMap('notes');\n\n...\n\n// Accessing a DDS\nthis.notesMap = await this.root.get<IFluidHandle<SharedMap>>(\"notes\").get();\n\n...\n\n// Using a DDS\npublic createNote = (text: string): void => {\n  const note: INote = {\n      id: uuidv4(),\n      text: text,\n      user: this.getUser()\n  };\n  this.notesMap.set(note.id, note);\n}\n\n...\n\n// Handling DDS changes\nprivate createEventListeners(sharedMap: SharedMap): void {\n    // Set up an event listener for changes to values in the SharedMap\n    sharedMap.on(\"valueChanged\", () => {\n        this.emit(\"change\");\n    });\n}\n\n```\n\n\n### Additional Resources\n\n* <a href=\"https://github.com/microsoft/FluidExamples\" target=\"_blank\">Brainstorm Repository</a>\n"},"stories/clicker.stories.mdx":{"raw":"import { Story, Meta } from '@storybook/addon-docs/blocks';\nimport { FluidLoader } from '../fluidRendering/fluidLoader';\nimport { Clicker, ClickerContainerFactory } from '../fluidObjects/clicker/clicker';\n\n<Meta title=\"React Demos/Clicker\" parameters={{ defaultSrcFile: './src/fluidObjects/clicker/clicker.tsx'}} />\n\n# Clicker Demo\n\nThis example demonstrates a clicker Fluid object used in real-time collaboration. The Fluid object\nuses the `SharedCounter` DDS located in the `@fluidframework/counter` package to keep track of clicks\nmade by different users. `SharedCounter` allows whole numbers to be incremented.\n\n<a href=\"https://fluidframework.com/docs/concepts/dds/\" target=\"_blank\">Distributed data structures</a> (DDSes) used include:\n\n* <a href=\"https://fluidframework.com/apis/counter/sharedcounter/\" target=\"_blank\">SharedCounter</a>\n\n<Story name=\"Demo\">\n  <FluidLoader factory={ClickerContainerFactory} title={Clicker.DataObjectName}></FluidLoader>\n</Story>\n\n<br /><br />\n\n### Code Highlights\n\nHere's a few highlights of how SharedCounter is used in this example. Click the **Source** tab above to view all of the code.\n\n```typescript\n// clicker.tsx\n// Define SharedCounter property\nprivate _counter: SharedCounter | undefined;\n\n...\n\n// Creating DDSes\nprotected async initializingFirstTime() {\n    const counter = SharedCounter.create(this.runtime);\n    this.root.set(counterKey, counter.handle);\n}\n\n...\n\n// Accessing DDSes\nconst counterHandle = this.root.get<IFluidHandle<SharedCounter>>(counterKey);\nthis._counter = await counterHandle.get();\n\n...\n\n// Changing DDSes\n<button style={{fontSize: 20}} onClick={() => { this.props.counter.increment(1); }}>+</button>\n\n...\n\n// Receiving Change Event on DDSes \nthis.props.counter.on(\"incremented\", (incrementValue: number, currentValue: number) => {\n    this.setState({ value: currentValue });\n});\n\n```\n\n### Additional Resources\n\n* <a href=\"https://github.com/microsoft/FluidFramework/tree/main/examples/data-objects/clicker\" target=\"_blank\">Clicker Repository</a>\n"},"stories/diceRoller.stories.mdx":{"raw":"import { Story, Meta } from '@storybook/addon-docs/blocks';\nimport { FluidLoader } from '../fluidRendering/fluidLoader';\nimport { DiceRoller } from '../fluidObjects/diceRoller/DiceRoller';\nimport { DiceRollerContainer } from '../fluidObjects/diceRoller/DiceRollerContainer';\nimport { DiceRollerView } from '../fluidObjects/diceRoller/DiceRollerView';\n\n<Meta title=\"React Demos/Dice Roller\" parameters={{ defaultSrcFile: './src/fluidObjects/diceRoller/DiceRoller.ts'}} />\n\n# Dice Roller\n\nThis example demonstrates a dice roller Fluid object. It allows multiple\nusers to roll a die in real-time and show the result to all collaborators. This example uses\nTypeScript and React to render the output. Another example that uses vanilla JavaScript is also available. \n\n<a href=\"https://fluidframework.com/docs/concepts/dds/\" target=\"_blank\">Distributed data structures</a> (DDSes) used include:\n\n* <a href=\"https://fluidframework.com/apis/map/shareddirectory/\" target=\"_blank\">SharedDirectory</a>\n\n<Story name=\"Demo\">\n  <FluidLoader factory={DiceRollerContainer} title={DiceRoller.DataObjectName} view={DiceRollerView} viewType=\"react\"></FluidLoader>\n</Story>\n\n<br /><br />\n\n### Code Highlights\n\nHere are a few highlights of how SharedMap is used in this example. Click the **Source** tab above to \nview all of the code.\n\n```typescript\n/* \n * diceRoller/DiceRoller.ts\n * This example uses the DataObject's `root` property which is a SharedDirectory DDS\n * The `diceValueKey` property below is used to get/set values on the SharedDirectory\n */\nconst diceValueKey = \"diceValueKey\";\n\n...\n\n// Accessing and using SharedDirectory\nprotected async initializingFirstTime() {\n    this.root.set(diceValueKey, 1);\n}\n\npublic get value(): number {\n    return this.root.get(diceValueKey);\n}\n\npublic readonly roll = () => {\n    const rollValue = Math.floor(Math.random() * 6) + 1;\n    this.root.set(diceValueKey, rollValue);\n};\n\n...\n\n// Handling DDS changes\nprotected async hasInitialized() {\n    this.root.on(\"valueChanged\", (changed: IValueChanged) => {\n        if (changed.key === diceValueKey) {\n            this.emit(\"diceRolled\");\n        }\n    });\n}\n```\n\n### Additional Resources\n\n* <a href=\"https://fluidframework.com/docs/get-started/quick-start/\" target=\"_blank\">Dice Roller Quick Start</a>\n* <a href=\"https://github.com/microsoft/FluidFramework/tree/main/examples/data-objects/diceroller\" target=\"_blank\">Dice Roller Repository</a>\n"},"stories/diceRollerJS.stories.mdx":{"raw":"import { Story, Meta } from '@storybook/addon-docs/blocks';\nimport { FluidLoader } from '../fluidRendering/fluidLoader';\nimport { DiceRoller } from '../fluidObjects/diceRollerJS/DiceRoller';\nimport { DiceRollerContainer } from '../fluidObjects/diceRollerJS/DiceRollerContainer';\nimport { DiceRollerView } from '../fluidObjects/diceRollerJS/DiceRollerView';\n\n<Meta title=\"JS Demos/Dice Roller JS\" parameters={{ defaultSrcFile: './src/fluidObjects/diceRollerJS/DiceRoller.js'}} />\n\n# Dice Roller JS\n\nThis example demonstrates a dice roller Fluid object. It allows multiple\nusers to roll a die in real-time and show the result to all collaborators. The example \nuses JavaScript and the DOM to render the output.\n\n<a href=\"https://fluidframework.com/docs/concepts/dds/\" target=\"_blank\">Distributed data structures</a> (DDSes) used include:\n\n* <a href=\"https://fluidframework.com/apis/map/shareddirectory/\" target=\"_blank\">SharedDirectory</a>\n\n<Story name=\"Demo\">\n    <FluidLoader factory={DiceRollerContainer} title={DiceRoller.DataObjectName} view={DiceRollerView} viewType=\"js\"></FluidLoader>\n</Story>\n\n<br /><br />\n\n### Code Highlights\n\nHere are a few highlights of how SharedMap is used in this example. Click the **Source** tab above to \nview all of the code.\n\n```typescript\n/* \n * diceRoller/DiceRoller.js\n * This example uses the DataObject's `root` property which is a SharedDirectory DDS\n * The `diceValueKey` property below is used to get/set values on the SharedDirectory\n */\nconst diceValueKey = \"diceValueKey\";\n\n...\n\n// Accessing and using SharedDirectory\nprotected async initializingFirstTime() {\n    this.root.set(diceValueKey, 1);\n}\n\npublic get value(): number {\n    return this.root.get(diceValueKey);\n}\n\npublic readonly roll = () => {\n    const rollValue = Math.floor(Math.random() * 6) + 1;\n    this.root.set(diceValueKey, rollValue);\n};\n\n...\n\n// Handling DDS changes\nasync hasInitialized() {\n    this.root.on(\"valueChanged\", (changed) => {\n        if (changed.key === diceValueKey) {\n            this.emit(\"diceRolled\");\n        }\n    });\n}\n\n\n```"},"stories/draft-js.stories.mdx":{"raw":"import { Story, Meta } from '@storybook/addon-docs/blocks';\nimport { FluidLoader } from '../fluidRendering/fluidLoader';\nimport { FluidDraftJsObject, FluidDraftJsContainer, FluidDraftJsView } from \"../fluidObjects/draft-js\";\n\n<Meta title=\"React Demos/Draft-JS\" parameters={{ defaultSrcFile: './src/fluidObjects/draft-js/fluid-object/FluidDraftJs.tsx'}} />\n\n# Draft-JS\n\nThis example demonstrates integrating Fluid into draft-js to provide real-time collaboration\nbetween multiple rich-text editors. \n\n<a href=\"https://fluidframework.com/docs/concepts/dds/\" target=\"_blank\">Distributed data structures</a> (DDSes) used include:\n\n* <a href=\"https://fluidframework.com/apis/map/sharedmap/\" target=\"_blank\">SharedMap</a>\n* <a href=\"https://fluidframework.com/apis/sequence/sharedstring/\" target=\"_blank\">SharedString</a>\n\n<Story name=\"Demo\">\n  <FluidLoader factory={FluidDraftJsContainer} title={FluidDraftJsObject.Name} view={FluidDraftJsView} viewType=\"react\"></FluidLoader>\n</Story>\n\n<br /><br />\n\n### Code Highlights\n\nHere's a few highlights of how SharedString is used in this example. Click the **Source** tab above to view all of the code.\n\n```typescript\n// fluid-object/FluidDraftJs.tsx\n// Define SharedString property\npublic text: SharedString | undefined;\n\n...\n\n// Creating DDSes\nconst text = SharedString.create(this.runtime);\ninsertBlockStart(text, 0);\ntext.insertText(text.getLength(), \"starting text\");\nthis.root.set(\"text\", text.handle);\n\n...\n\n// Accessing DDSes - SharedString is passed to Fluid Editor React Component\n<FluidEditor\n    sharedString={props.model.text}\n/>\n\n// Changing DDSes\nthis.props.sharedString.insertText(start, insertedText, styleProp);\nthis.props.sharedString.replaceText(start, end, insertedText, styleProp);\n\n...\n\n// Receiving Change Event on DDSes - view/FluidEditor.tsx\nthis.props.sharedString.on(\"sequenceDelta\", (event: SequenceDeltaEvent) => {\n...\n    const updateSelectionRange = (textRange: TextRange) => updateTextRange(event.ranges, textRange);\n    this.updateEditorState(updateSelectionRange);\n...\n}\n```\n\n### Additional Resources\n\n* <a href=\"https://github.com/microsoft/FluidExamples\" target=\"_blank\">draft-js Repository</a>\n"},"stories/image-gallery.stories.mdx":{"raw":"import { Story, Meta } from '@storybook/addon-docs/blocks';\nimport { FluidLoader } from '../fluidRendering/fluidLoader';\nimport { fluidExport, ImageGalleryInstantiationFactory } from '../fluidObjects/image-gallery/image-gallery';\n\n<Meta title=\"React Demos/Image Gallery\" parameters={{ defaultSrcFile: './src/fluidObjects/image-gallery/image-gallery.tsx'}} />\n\n# Image Gallery\n\nThis example demonstrates using Fluid objects to provide real-time collaboration\nbetween multiple image gallery components. As a user selects an image, other connected\nclients will automatically be updated and stay in sync.\n\n<a href=\"https://fluidframework.com/docs/concepts/dds/\" target=\"_blank\">Distributed data structures</a> (DDSes) used include:\n\n* <a href=\"https://fluidframework.com/apis/map/shareddirectory/\" target=\"_blank\">SharedDirectory</a>\n\n<Story name=\"Demo\">\n  <FluidLoader factory={fluidExport} title={ImageGalleryInstantiationFactory.type}></FluidLoader>\n</Story>\n\n<br /><br />\n\n### Code Highlights\n\nHere's how the default Root directory is used in this example. Click the **Source** tab above to view all of the code.\n\n```typescript\n// image-gallery.tsx\n// Root DDS creation is done by DataObject class\nexport class ImageGalleryComponent extends DataObject implements IFluidHTMLView\n\n...\n\n// Accessing DDSes\nthis.root.get(\"position\");\n\n...\n\n// Changing DDSes\nonSlide = (index: number) => {\n    this.root.set(\"position\", index);\n};\n\n...\n\n// Receiving Change Event on DDSes \nthis.root.on(\"valueChanged\", (_, local) => {\n    const position = this.root.get<number>(\"position\");\n    ...\n}\n\n```\n\n### Additional Resources\n\n* <a href=\"https://github.com/microsoft/FluidFramework/tree/main/examples/data-objects/image-gallery\" target=\"_blank\">Image Gallery Repository</a>\n"},"stories/prosemirror.stories.mdx":{"raw":"import { Story, Meta } from '@storybook/addon-docs/blocks';\nimport { FluidLoader } from '../fluidRendering/fluidLoader';\nimport { fluidExport } from '../fluidObjects/prosemirror/index';\n\n<Meta title=\"React Demos/ProseMirror\" parameters={{ defaultSrcFile: './src/fluidObjects/prosemirror/prosemirror.ts'}} />\n\n# ProseMirror\n\nThis example demonstrates integrating Fluid objects into ProseMirror to provide real-time collaboration\nbetween multiple rich-text editors.\n\n<a href=\"https://fluidframework.com/docs/concepts/dds/\" target=\"_blank\">Distributed data structures</a> (DDSes) used include:\n\n* <a href=\"https://fluidframework.com/apis/map/sharedmap/\" target=\"_blank\">SharedMap</a>\n* <a href=\"https://fluidframework.com/apis/sequence/sharedstring/\" target=\"_blank\">SharedString</a>\n\n<Story name=\"Demo\">\n  <FluidLoader factory={fluidExport} title={fluidExport.defaultDataObjectName}></FluidLoader>\n</Story>\n\n<br /><br />\n\n### Code Highlights\n\nHere are a few highlights of how SharedMap and SharedString are used in this example. Click the **Source** tab above to \nview all of the code.\n\n```typescript\n// prosemirror/prosemirror.ts\n// Define DDS properties\npublic text!: SharedString;\nprivate root!: ISharedMap;\n\n...\n\n// Creating DDSes\nthis.root = SharedMap.create(this.runtime, \"root\");\nconst text = SharedString.create(this.runtime);\nthis.root.set(\"text\", text.handle);\n\n...\n\n// Accessing DDSes\nthis.root = await this.runtime.getChannel(\"root\") as ISharedMap;\nthis.text = await this.root.get<IFluidHandle<SharedString>>(\"text\").get();\n\n...\n\n// Using DDSes\ntext.insertText(1, \"Hello, world!\");\n```\n\n### Additional Resources\n\n* <a href=\"https://github.com/microsoft/FluidFramework/tree/main/examples/data-objects/prosemirror\" target=\"_blank\">ProseMirror Repository</a>\n"},"stories/sudoku.stories.mdx":{"raw":"import { Story, Meta } from '@storybook/addon-docs/blocks';\nimport { FluidLoader } from '../fluidRendering/fluidLoader';\nimport { fluidExport, FluidSudokuName } from '../fluidObjects/sudoku/index';\n\n<Meta title=\"React Demos/Sudoku\" parameters={{ defaultSrcFile: './src/fluidObjects/sudoku/fluidSudoku.tsx'}} />\n\n# Sudoku\n\nThis example allows multiple users to collaborate in real-time on a game of Sudoku.\n\n<a href=\"https://fluidframework.com/docs/concepts/dds/\" target=\"_blank\">Distributed data structures</a> (DDSes) used include:\n\n* <a href=\"https://fluidframework.com/apis/map/sharedmap/\" target=\"_blank\">SharedMap</a>\n\n<Story name=\"Demo\">\n  <FluidLoader factory={fluidExport} title={FluidSudokuName}></FluidLoader>\n</Story>\n\n<br /><br />\n\n### Code Highlights\n\nHere are a few highlights of how SharedMap is used in this example. Click the **Source** tab above to \nview all of the code.\n\n```typescript\n// brainstorm/fluid-object/main.ts\n// Define DDS property\nprivate notesMap: SharedMap;\n\n...\n\n// Create a DDS\nconst map = SharedMap.create(this.runtime);\n\n...\n\n// Accessing a DDS\nthis.puzzle = await this.root.get<IFluidHandle<ISharedMap>>(this.sudokuMapKey).get();\n\n...\n\n// Using a DDS\nexport function loadPuzzle(index: number, puzzleMap: ISharedMap): number[][] {\n    const puzzleInput = PUZZLES[index];\n    const solution = sudoku.solve(puzzleInput);\n\n    for (const row of PUZZLE_INDEXES) {\n        for (const col of PUZZLE_INDEXES) {\n            const key = Coordinate.asString(row, col);\n            const cell = new SudokuCell(puzzleInput[row][col], solution[row][col], key);\n            puzzleMap.set(key, cell);\n        }\n    }\n    return solution;\n}\n\n...\n\n// Handling DDS changes\nprotected async hasInitialized() {\n    this.puzzle.on(\"valueChanged\", (changed, local, op) => {\n        this.render();\n    });\n}\n```\n\n### Additional Resources\n\n* <a href=\"https://github.com/microsoft/FluidExamples\" target=\"_blank\">Sudoku Repository</a>\n"},"stories/table.stories.mdx":{"raw":"import { Story, Meta } from '@storybook/addon-docs/blocks';\nimport { FluidLoader } from '../fluidRendering/fluidLoader';\nimport { FluidTable, TableContainerFactory } from '../fluidObjects/table/TableModel';\n\n<Meta title=\"React Demos/Table\" parameters={{ defaultSrcFile: './src/fluidObjects/table/TableModel.tsx'}} />\n\n# Table\n\nThis example demonstrates real-time collaboration between multiple tables. Users can collaborate on adding new rows, \nrenaming columns, and updating values in the table.\n\n<a href=\"https://fluidframework.com/docs/concepts/dds/\" target=\"_blank\">Distributed data structures</a> (DDSes) used include:\n\n* <a href=\"https://fluidframework.com/apis/matrix/sharedmatrix/\" target=\"_blank\">SharedMatrix</a>\n\n\n<Story name=\"Demo\">\n  <FluidLoader factory={TableContainerFactory} title={FluidTable.FluidObjectName}></FluidLoader>\n</Story>\n\n<br /><br />\n\n### Code Highlights\n\nHere's a few highlights of how SharedMatrix is used in this example. Click the **Source** tab above to view all of the code.\nNote: The SharedMatrix has a different eventing model than the other DDSes. .OpenMatrix() calls functions instead of creating events.\n```typescript\n// TableModel.tsx\n// Define SharedMatrix property\nprivate _matrixData!: SharedMatrix<string>;\n\n...\n\n// Creating DDSes\nconst matrixDDSObject = SharedMatrix.create(this.runtime);\n\n...\n\n// Accessing DDSes\nconst matrixDDSObjectHandle = this.root.get<IFluidHandle<SharedMatrix<string>>>(matrixDataStoreKey);\nthis._matrixData = await matrixDDSObjectHandle.get();\n\n...\n\n// Changing DDSes\nthis._matrixData.setCell(row, col, value);\nthis._matrixData.insertCols(colStart, count);\nthis._matrixData.insertRows(rowStart, count);\n\n...\n\n// Receiving Change Event on DDSes \nthis._matrixData.openMatrix(this);\npublic rowsChanged(rowStart: number, removedCount: number, insertedCount: number, producer: IMatrixProducer<string>) {\n    this.emit(\"rowsChanged\", this.rows);\n}\n\npublic colsChanged(colStart: number, removedCount: number, insertedCount: number, producer: IMatrixProducer<string>) {\n    this.emit(\"colsChanged\", this.cols);\n}\n\npublic cellsChanged(rowStart: number, colStart: number, rowCount: number, colCount: number, producer: IMatrixProducer<string>) {\n    this.emit(\"cellChanged\", rowStart, colStart, this.getCell(rowStart, colStart));\n}\n\n```\n\n### Additional Resources\n\n* <a href=\"https://github.com/microsoft/FluidFramework/tree/main/examples/data-objects/clicker\" target=\"_blank\">Clicker Repository</a>\n"}}}